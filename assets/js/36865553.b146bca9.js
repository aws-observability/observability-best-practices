"use strict";(self.webpackChunkobservability_best_practices=self.webpackChunkobservability_best_practices||[]).push([[9208],{54840:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var n=o(74848),r=o(28453);const s={},i="Operating the AWS Distro for OpenTelemetry (ADOT) Collector",l={id:"guides/operational/adot-at-scale/operating-adot-collector",title:"Operating the AWS Distro for OpenTelemetry (ADOT) Collector",description:"The ADOT collector is a downstream distribution of the open-source OpenTelemetry Collector by CNCF.",source:"@site/docs/guides/operational/adot-at-scale/operating-adot-collector.md",sourceDirName:"guides/operational/adot-at-scale",slug:"/guides/operational/adot-at-scale/operating-adot-collector",permalink:"/observability-best-practices/docs/guides/operational/adot-at-scale/operating-adot-collector",draft:!1,unlisted:!1,editUrl:"https://github.com/aws-observability/observability-best-practices/docs/guides/operational/adot-at-scale/operating-adot-collector.md",tags:[],version:"current",frontMatter:{},sidebar:"guides",previous:{title:"Best practices for hybrid and multicloud",permalink:"/observability-best-practices/docs/guides/hybrid-and-multicloud"},next:{title:"Instrumenting Java Spring Integration Applications",permalink:"/observability-best-practices/docs/guides/operational/adot-at-scale/adot-java-spring/"}},a={},c=[{value:"Deployment architecture",id:"deployment-architecture",level:2},{value:"No Collector",id:"no-collector",level:3},{value:"Agent",id:"agent",level:3},{value:"Pros and Cons",id:"pros-and-cons",level:5},{value:"Running the collector as a Daemonset on Amazon EKS",id:"running-the-collector-as-a-daemonset-on-amazon-eks",level:4},{value:"Pros and Cons",id:"pros-and-cons-1",level:5},{value:"Running the collector on Amazon EC2",id:"running-the-collector-on-amazon-ec2",level:4},{value:"Running the collector as Deployment on Amazon EKS",id:"running-the-collector-as-deployment-on-amazon-eks",level:4},{value:"Running the collector as a central task on Amazon ECS for metrics collection",id:"running-the-collector-as-a-central-task-on-amazon-ecs-for-metrics-collection",level:4},{value:"Pros and Cons",id:"pros-and-cons-2",level:5},{value:"Gateway",id:"gateway",level:3},{value:"Managing Collector health",id:"managing-collector-health",level:2},{value:"Collecting health metrics from the Collector",id:"collecting-health-metrics-from-the-collector",level:3},{value:"Collector health check",id:"collector-health-check",level:4},{value:"Setting limits to prevent catastrophic failures",id:"setting-limits-to-prevent-catastrophic-failures",level:4},{value:"Limiting Memory usage",id:"limiting-memory-usage",level:5},{value:"Backpressure management",id:"backpressure-management",level:4},{value:"Handling out-of-order samples in Prometheus metric collection",id:"handling-out-of-order-samples-in-prometheus-metric-collection",level:5},{value:"Solving out of order sample error",id:"solving-out-of-order-sample-error",level:6},{value:"Open Agent Management Protocol (OpAMP)",id:"open-agent-management-protocol-opamp",level:4},{value:"Horizontal Scaling",id:"horizontal-scaling",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"operating-the-aws-distro-for-opentelemetry-adot-collector",children:"Operating the AWS Distro for OpenTelemetry (ADOT) Collector"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"https://aws-otel.github.io/",children:"ADOT collector"})," is a downstream distribution of the open-source ",(0,n.jsx)(t.a,{href:"https://opentelemetry.io/docs/collector/",children:"OpenTelemetry Collector"})," by ",(0,n.jsx)(t.a,{href:"https://www.cncf.io/",children:"CNCF"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Customers can use the ADOT Collector to collect signals such as metrics and traces from different environments including on-prem, AWS and from other cloud providers."}),"\n",(0,n.jsx)(t.p,{children:"In order to operate the ADOT Collector in a real world environment and at scale, operators should monitor the collector health, and scale as needed. In this guide, you will learn about the actions one can take to operate the ADOT Collector in a production environment."}),"\n",(0,n.jsx)(t.h2,{id:"deployment-architecture",children:"Deployment architecture"}),"\n",(0,n.jsx)(t.p,{children:"Depending on the your requirements, there are a few deployment options that you might want to consider."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"No Collector"}),"\n",(0,n.jsx)(t.li,{children:"Agent"}),"\n",(0,n.jsx)(t.li,{children:"Gateway"}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"tip",children:(0,n.jsxs)(t.p,{children:["Check out the ",(0,n.jsx)(t.a,{href:"https://opentelemetry.io/docs/collector/deployment/",children:"OpenTelemetry documentation"}),"\nfor additional information on these concepts."]})}),"\n",(0,n.jsx)(t.h3,{id:"no-collector",children:"No Collector"}),"\n",(0,n.jsxs)(t.p,{children:["This option essentially skips the collector from the equation completely. If you are not aware, it is possible to make the API calls to destination services directly from the OTEL SDK and send the signals. Think about you making calls to the AWS X-Ray's ",(0,n.jsx)(t.a,{href:"https://docs.aws.amazon.com/xray/latest/api/API_PutTraceSegments.html",children:"PutTraceSegments"})," API directly from your application process instead of sending the spans to an out-of-process agent such as the ADOT Collector."]}),"\n",(0,n.jsxs)(t.p,{children:["We strongly encourage you to take a look at the ",(0,n.jsx)(t.a,{href:"https://opentelemetry.io/docs/collector/deployment/no-collector/",children:"section"})," in the upstream documentation for more specifics as there isn't any AWS specific aspect that changes the guidance for this approach."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"No Collector option",src:o(7872).A+"",width:"761",height:"481"})}),"\n",(0,n.jsx)(t.h3,{id:"agent",children:"Agent"}),"\n",(0,n.jsxs)(t.p,{children:["In this approach, you will run the collector in a distributed manner and collect signals into the destinations. Unlike the ",(0,n.jsx)(t.code,{children:"No Collector"})," option, here we separate the concerns and decouple the application from having to use its resources to make remote API calls and instead communicate to a locally accessible agent."]}),"\n",(0,n.jsxs)(t.p,{children:["Essentially it will look like this below in an Amazon EKS environment ",(0,n.jsx)(t.strong,{children:"running the collector as a Kubernetes sidecar:"})]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ADOT Collector Sidecar",src:o(38940).A+"",width:"761",height:"481"})}),"\n",(0,n.jsxs)(t.p,{children:["In this above architecture, your scrape configuration shouldn't really have to make use of any service discovery mechanisms at all since you will be scraping the targets from ",(0,n.jsx)(t.code,{children:"localhost"})," given that the collector is running in the same pod as the application container."]}),"\n",(0,n.jsxs)(t.p,{children:["The same architecture applies to collecting traces as well. You will simply have to create a OTEL pipeline as ",(0,n.jsx)(t.a,{href:"https://aws-otel.github.io/docs/getting-started/x-ray#sample-collector-configuration-putting-it-together",children:"shown here"})]}),"\n",(0,n.jsx)(t.h5,{id:"pros-and-cons",children:"Pros and Cons"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"One argument advocating for this design is that you don't have to allocate extra-ordinary amount of resources (CPU, Memory) for the Collector to do its job since the targets are limited to localhost sources."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The disadvantage of using this approach could be that, the number of varied configurations for the collector pod configuration is directly proportional to the number of applications you are running on the cluster.\nThis means, you will have to manage CPU, Memory and other resource allocation individually for each Pod depending on the workload that is expected for the Pod. By not being careful with this, you might over or under-allocate resources for the Collector Pod that will result in either under-performing or locking up CPU cycles and Memory which could otherwise be used by other Pods in the Node."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"You could also deploy the collector in other models such as Deployments, Daemonset, Statefulset etc based on your needs."}),"\n",(0,n.jsx)(t.h4,{id:"running-the-collector-as-a-daemonset-on-amazon-eks",children:"Running the collector as a Daemonset on Amazon EKS"}),"\n",(0,n.jsxs)(t.p,{children:["You can choose to run the collector as a ",(0,n.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/",children:"Daemonset"})," in case you want to evenly distribute the load (scraping and sending the metrics to Amazon Managed Service for Prometheus workspace) of the collectors across the EKS Nodes."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ADOT Collector Daemonset",src:o(17433).A+"",width:"761",height:"481"})}),"\n",(0,n.jsxs)(t.p,{children:["Ensure you have the ",(0,n.jsx)(t.code,{children:"keep"})," action that makes the collector only scrape targets from its own host/Node."]}),"\n",(0,n.jsxs)(t.p,{children:["See sample below for reference. Find more such configuration details ",(0,n.jsx)(t.a,{href:"https://aws-otel.github.io/docs/getting-started/adot-eks-add-on/config-advanced#daemonset-collector-configuration",children:"here."})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:"scrape_configs:\n    - job_name: kubernetes-apiservers\n    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n    kubernetes_sd_configs:\n    - role: endpoints\n    relabel_configs:\n    - action: keep\n        regex: $K8S_NODE_NAME\n        source_labels: [__meta_kubernetes_endpoint_node_name]\n    scheme: https\n    tls_config:\n        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n        insecure_skip_verify: true\n"})}),"\n",(0,n.jsx)(t.p,{children:"The same architecture can also be used for collecting traces. In this case, instead of the Collector reaching out to the endpoints to scrape Prometheus metrics, the trace spans will be sent to the Collector by the application pods."}),"\n",(0,n.jsx)(t.h5,{id:"pros-and-cons-1",children:"Pros and Cons"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Advantages"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Minimal scaling concerns"}),"\n",(0,n.jsx)(t.li,{children:"Configuring High-Availability is a challenge"}),"\n",(0,n.jsx)(t.li,{children:"Too many copies of Collector in use"}),"\n",(0,n.jsx)(t.li,{children:"Can be easy for Logs support"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Disadvantages"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Not the most optimal in terms of resource utilization"}),"\n",(0,n.jsx)(t.li,{children:"Disproportionate resource allocation"}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"running-the-collector-on-amazon-ec2",children:"Running the collector on Amazon EC2"}),"\n",(0,n.jsx)(t.p,{children:"As there is no side car approach in running the collector on EC2, you would be running the collector as an agent on the EC2 instance. You can set a static scrape configuration such as the one below to discover targets in the instance to scrape metrics from."}),"\n",(0,n.jsxs)(t.p,{children:["The config below scrapes endpoints at ports ",(0,n.jsx)(t.code,{children:"9090"})," and ",(0,n.jsx)(t.code,{children:"8081"})," on localhost."]}),"\n",(0,n.jsxs)(t.p,{children:["Get a hands-on deep dive experience in this topic by going through our ",(0,n.jsx)(t.a,{href:"https://catalog.workshops.aws/observability/en-US/aws-managed-oss/ec2-monitoring",children:"EC2 focused module in the One Observability Workshop."})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:"global:\n  scrape_interval: 15s # By default, scrape targets every 15 seconds.\n\nscrape_configs:\n- job_name: 'prometheus'\n  static_configs:\n  - targets: ['localhost:9090', 'localhost:8081']\n"})}),"\n",(0,n.jsx)(t.h4,{id:"running-the-collector-as-deployment-on-amazon-eks",children:"Running the collector as Deployment on Amazon EKS"}),"\n",(0,n.jsx)(t.p,{children:"Running the collector as a Deployment is particularly useful when you want to also provide High Availability for your collectors. Depending on the number of targets, metrics available to scrape etc the resources for the Collector should be adjusted to ensure the collector isn't starving and hence causing issues in signal collection."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://aws-observability.github.io/observability-best-practices/guides/containers/oss/eks/best-practices-metrics-collection",children:"Read more about this topic in the guide here."})}),"\n",(0,n.jsx)(t.p,{children:"The following architecture shows how a collector is deployed in a separate node outside of the workload nodes to collect metrics and traces."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ADOT Collector Deployment",src:o(54682).A+"",width:"761",height:"711"})}),"\n",(0,n.jsxs)(t.p,{children:["To setup High-Availability for metric collection, ",(0,n.jsx)(t.a,{href:"https://docs.aws.amazon.com/prometheus/latest/userguide/Send-high-availability-prom-community.html",children:"read our docs that provide detailed instructions on how you can set that up"})]}),"\n",(0,n.jsx)(t.h4,{id:"running-the-collector-as-a-central-task-on-amazon-ecs-for-metrics-collection",children:"Running the collector as a central task on Amazon ECS for metrics collection"}),"\n",(0,n.jsxs)(t.p,{children:["You can use the ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/extension/observer/ecsobserver",children:"ECS Observer extension"})," to collect Prometheus metrics across different tasks in an ECS cluster or across clusters."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ADOT Collector Deployment ECS",src:o(98672).A+"",width:"761",height:"711"})}),"\n",(0,n.jsx)(t.p,{children:"Sample collector configuration for the extension:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:"extensions:\n  ecs_observer:\n    refresh_interval: 60s # format is https://golang.org/pkg/time/#ParseDuration\n    cluster_name: 'Cluster-1' # cluster name need manual config\n    cluster_region: 'us-west-2' # region can be configured directly or use AWS_REGION env var\n    result_file: '/etc/ecs_sd_targets.yaml' # the directory for file must already exists\n    services:\n      - name_pattern: '^retail-.*$'\n    docker_labels:\n      - port_label: 'ECS_PROMETHEUS_EXPORTER_PORT'\n    task_definitions:\n      - job_name: 'task_def_1'\n        metrics_path: '/metrics'\n        metrics_ports:\n          - 9113\n          - 9090\n        arn_pattern: '.*:task-definition/nginx:[0-9]+'\n"})}),"\n",(0,n.jsx)(t.h5,{id:"pros-and-cons-2",children:"Pros and Cons"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"An advantage in this model is that there are fewer collectors and configurations to manage yourself."}),"\n",(0,n.jsx)(t.li,{children:"When the cluster is rather large and there are thousands of targets to scrape, you will have to carefully design the architecture in such a way that the load is balanced across the collectors. Adding this to having to run near-clones of the same collectors for HA reasons should be done carefully in order to avoid operational issues."}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"gateway",children:"Gateway"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ADOT Collector Gateway",src:o(37957).A+"",width:"841",height:"531"})}),"\n",(0,n.jsx)(t.h2,{id:"managing-collector-health",children:"Managing Collector health"}),"\n",(0,n.jsx)(t.p,{children:"The OTEL Collector exposes several signals for us to keep tab of its health and performance. It is essential that the collector's health is closely monitored in order to take corrective actions such as,"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Scaling the collector horizontally"}),"\n",(0,n.jsx)(t.li,{children:"Provisioning additional resources to the collector for it to function as desired"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"collecting-health-metrics-from-the-collector",children:"Collecting health metrics from the Collector"}),"\n",(0,n.jsxs)(t.p,{children:["The OTEL Collector can be configured to expose metrics in Prometheus Exposition Format by simply adding the ",(0,n.jsx)(t.code,{children:"telemetry"})," section to the ",(0,n.jsx)(t.code,{children:"service"})," pipeline. The collector also can expose its own logs to stdout."]}),"\n",(0,n.jsxs)(t.p,{children:["More details on telemetry configuration can be found in the ",(0,n.jsx)(t.a,{href:"https://opentelemetry.io/docs/collector/configuration/#service",children:"OpenTelemetry documentation here."})]}),"\n",(0,n.jsx)(t.p,{children:"Sample telemetry configuration for the collector."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:"service:\n  telemetry:\n    logs:\n      level: debug\n    metrics:\n      level: detailed\n      address: 0.0.0.0:8888\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Once configured, the collector will start exporting metrics such as this below at ",(0,n.jsx)(t.code,{children:"http://localhost:8888/metrics"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:'# HELP otelcol_exporter_enqueue_failed_spans Number of spans failed to be added to the sending queue.\n# TYPE otelcol_exporter_enqueue_failed_spans counter\notelcol_exporter_enqueue_failed_spans{exporter="awsxray",service_instance_id="523a2182-539d-47f6-ba3c-13867b60092a",service_name="aws-otel-collector",service_version="v0.25.0"} 0\n\n# HELP otelcol_process_runtime_total_sys_memory_bytes Total bytes of memory obtained from the OS (see \'go doc runtime.MemStats.Sys\')\n# TYPE otelcol_process_runtime_total_sys_memory_bytes gauge\notelcol_process_runtime_total_sys_memory_bytes{service_instance_id="523a2182-539d-47f6-ba3c-13867b60092a",service_name="aws-otel-collector",service_version="v0.25.0"} 2.4462344e+07\n\n# HELP otelcol_process_memory_rss Total physical memory (resident set size)\n# TYPE otelcol_process_memory_rss gauge\notelcol_process_memory_rss{service_instance_id="523a2182-539d-47f6-ba3c-13867b60092a",service_name="aws-otel-collector",service_version="v0.25.0"} 6.5675264e+07\n\n# HELP otelcol_exporter_enqueue_failed_metric_points Number of metric points failed to be added to the sending queue.\n# TYPE otelcol_exporter_enqueue_failed_metric_points counter\notelcol_exporter_enqueue_failed_metric_points{exporter="awsxray",service_instance_id="d234b769-dc8a-4b20-8b2b-9c4f342466fe",service_name="aws-otel-collector",service_version="v0.25.0"} 0\notelcol_exporter_enqueue_failed_metric_points{exporter="logging",service_instance_id="d234b769-dc8a-4b20-8b2b-9c4f342466fe",service_name="aws-otel-collector",service_version="v0.25.0"} 0\n'})}),"\n",(0,n.jsxs)(t.p,{children:["In the above sample output, you can see that the collector is exposing a metric called ",(0,n.jsx)(t.code,{children:"otelcol_exporter_enqueue_failed_spans"})," showing the number of spans that were failed to get added to the sending queue. This metric is one to watch out to understand if the collector is having issues in sending trace data to the destination configured. In this case, you can see that the ",(0,n.jsx)(t.code,{children:"exporter"})," label with value ",(0,n.jsx)(t.code,{children:"awsxray"})," indicating the trace destination in use."]}),"\n",(0,n.jsxs)(t.p,{children:["The other metric ",(0,n.jsx)(t.code,{children:"otelcol_process_runtime_total_sys_memory_bytes"})," is an indicator to understand the amount of memory being used by the collector. If this memory goes too close to the value in ",(0,n.jsx)(t.code,{children:"otelcol_process_memory_rss"})," metric, that is an indication that the Collector is getting close to exhausting the allocated memory for the process and it might be time for you to take action such as allocating more memory for the collector to avoid issues."]}),"\n",(0,n.jsxs)(t.p,{children:["Likewise, you can see that there is another counter metric called ",(0,n.jsx)(t.code,{children:"otelcol_exporter_enqueue_failed_metric_points"})," that indicates the number of metrics that failed to be sent to the remote destination"]}),"\n",(0,n.jsx)(t.h4,{id:"collector-health-check",children:"Collector health check"}),"\n",(0,n.jsx)(t.p,{children:"There is a liveness probe that the collector exposes in-order for you to check whether the collector is live or not. It is recommended to use that endpoint to periodically check the collector's availability."}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/extension/healthcheckextension",children:(0,n.jsx)(t.code,{children:"healthcheck"})})," extension can be used to have the collector expose the endpoint. See sample configuration below:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:"extensions:\n  health_check:\n    endpoint: 0.0.0.0:13133\n"})}),"\n",(0,n.jsxs)(t.p,{children:["For the complete configuration options, refer to ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/extension/healthcheckextension",children:"the GitHub repo here."})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"\u276f curl -v http://localhost:13133\n*   Trying 127.0.0.1:13133...\n* Connected to localhost (127.0.0.1) port 13133 (#0)\n> GET / HTTP/1.1\n> Host: localhost:13133\n> User-Agent: curl/7.79.1\n> Accept: */*\n>\n* Mark bundle as not supporting multiuse\n< HTTP/1.1 200 OK\n< Date: Fri, 24 Feb 2023 19:09:22 GMT\n< Content-Length: 0\n<\n* Connection #0 to host localhost left intact\n"})}),"\n",(0,n.jsx)(t.h4,{id:"setting-limits-to-prevent-catastrophic-failures",children:"Setting limits to prevent catastrophic failures"}),"\n",(0,n.jsx)(t.p,{children:"Given that resources (CPU, Memory) are finite in any environment, you should set limits to the collector components in-order to avoid failures due to unforeseen situations."}),"\n",(0,n.jsx)(t.p,{children:"It is particularly important when you are operating the ADOT Collector to collect Prometheus metrics.\nTake this scenario - You are in the DevOps team and are responsible for deploying and operating the ADOT Collector in an Amazon EKS cluster. Your application teams can simply drop their application Pods at will anytime of the day, and they expect the metrics exposed from their pods to be collected into an Amazon Managed Service for Prometheus workspace."}),"\n",(0,n.jsx)(t.p,{children:"Now it is your responsibility to ensure that this pipeline works without any hiccups. There are two ways to solve this problem at a high level:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Scaling the collector infinitely (hence adding Nodes to the cluster if needed) to support this requirement"}),"\n",(0,n.jsx)(t.li,{children:"Set limits on metric collection and advertise the upper threshold to the application teams"}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["There are pros and cons to both approaches. You can argue that you want to choose option 1, if you are fully committed to supporting your ever growing business needs not considering the costs or the overhead that it might bring in. While supporting the ever growing business needs infinitely might sound like ",(0,n.jsx)(t.code,{children:"cloud is for infinite scalability"})," point of view, this can bring in a lot of operational overhead and might lead into much more catastrophical situations if not given infinite amount of time, and people resources to ensure continual uninterrupted operations, which in most cases is not practical."]}),"\n",(0,n.jsx)(t.p,{children:"A much more pragmatic and frugal approach would be to choose option 2, where you are setting upper limits (and potentially increasing gradually based on needs progressively) at any given time to ensure the operational boundary is obvious."}),"\n",(0,n.jsx)(t.p,{children:"Here is an example of how you can do that with using Prometheus receiver in the ADOT Collector."}),"\n",(0,n.jsxs)(t.p,{children:["In Prometheus ",(0,n.jsx)(t.a,{href:"https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config",children:"scrape_config,"})," you can set several limits for any particular scrape job. You could put limits on,"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The total body size of the scrape"}),"\n",(0,n.jsx)(t.li,{children:"Limit number of labels to accept (the scrape will be discarded if this limit exceeds and you can see that in the Collector logs)"}),"\n",(0,n.jsx)(t.li,{children:"Limit the number of targets to scrape"}),"\n",(0,n.jsx)(t.li,{children:"..more"}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["You can see all available options in the ",(0,n.jsx)(t.a,{href:"https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config",children:"Prometheus documentation."})]}),"\n",(0,n.jsx)(t.h5,{id:"limiting-memory-usage",children:"Limiting Memory usage"}),"\n",(0,n.jsxs)(t.p,{children:["The Collector pipeline can be configured to use ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector/tree/main/processor/memorylimiterprocessor",children:(0,n.jsx)(t.code,{children:"memorylimiterprocessor"})})," to limit the amount of memory the processor component will use. It is common to see customers wanting the Collector to do complex operations that require intense Memory and CPU requirements."]}),"\n",(0,n.jsxs)(t.p,{children:["While using processors such as ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/redactionprocessor",children:(0,n.jsx)(t.code,{children:"redactionprocessor,"})}),(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/filterprocessor",children:(0,n.jsx)(t.code,{children:"filterprocessor,"})}),(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/spanprocessor",children:(0,n.jsx)(t.code,{children:"spanprocessor,"})})," are exciting and very useful, you should also remember that processors in general deal with data transformation tasks and it requires them to keep data in-memory in-order to complete the tasks. This can lead to a specific processor breaking the Collector entirely and also the Collector not having enough memory to expose its own health metrics."]}),"\n",(0,n.jsxs)(t.p,{children:["You can avoid this by limiting the amount of memory the Collector can use by making use of the  ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector/tree/main/processor/memorylimiterprocessor",children:(0,n.jsx)(t.code,{children:"memorylimiterprocessor."})}),". The recommendation for this is to provide buffer memory for the Collector to make use of for exposing health metrics and perform other tasks so the processors do not take all the allocated memory."]}),"\n",(0,n.jsxs)(t.p,{children:["For example, if your EKS Pod has a memory limit of ",(0,n.jsx)(t.code,{children:"10Gi"}),", then set the ",(0,n.jsx)(t.code,{children:"memorylimitprocessor"})," to less than ",(0,n.jsx)(t.code,{children:"10Gi"}),", for example ",(0,n.jsx)(t.code,{children:"9Gi"})," so the buffer of ",(0,n.jsx)(t.code,{children:"1Gi"})," can be used to perform other operations such as exposing health metrics, receiver and exporter tasks."]}),"\n",(0,n.jsx)(t.h4,{id:"backpressure-management",children:"Backpressure management"}),"\n",(0,n.jsx)(t.p,{children:"Some architecture patterns (Gateway pattern) such as the one shown below can be used to centralize some operational tasks such as (but not limited to) filtering out sensitive data out of signal data to maintain compliance requirements."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ADOT Collector Simple Gateway",src:o(90804).A+"",width:"455",height:"292"})}),"\n",(0,n.jsxs)(t.p,{children:["However, it is possible to overwhelm the Gateway Collector with too many such ",(0,n.jsx)(t.em,{children:"processing"})," tasks that can cause issues. The recommended approach would be is to distribute the process/memory intense tasks between the individual collectors and the gateway so the workload is shared."]}),"\n",(0,n.jsxs)(t.p,{children:["For example, you could use the ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/resourceprocessor",children:(0,n.jsx)(t.code,{children:"resourceprocessor"})})," to process resource attributes and use the ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/transformprocessor",children:(0,n.jsx)(t.code,{children:"transformprocessor"})})," to transform the signal data from within the individual Collectors as soon as the signal collection happens."]}),"\n",(0,n.jsxs)(t.p,{children:["Then you could use the ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/filterprocessor",children:(0,n.jsx)(t.code,{children:"filterprocessor"})})," to filter out certain parts of the signal data and use the ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/redactionprocessor",children:(0,n.jsx)(t.code,{children:"redactionprocessor"})})," to redact sensitive information such as Credit Card numbers etc."]}),"\n",(0,n.jsx)(t.p,{children:"The high-level architecture diagram would look like the one below:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ADOT Collector Simple Gateway with processors",src:o(18354).A+"",width:"455",height:"362"})}),"\n",(0,n.jsxs)(t.p,{children:["As you might have observed already, the Gateway Collector can soon become a single point of failure. One obvious choice there is to spin up more than one Gateway Collector and proxy requests through a load balancer like ",(0,n.jsx)(t.a,{href:"https://aws.amazon.com/elasticloadbalancing/application-load-balancer/",children:"AWS Application Load Balancer (ALB)"})," as shown below."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ADOT Collector Gateway batching pressure",src:o(450).A+"",width:"842",height:"532"})}),"\n",(0,n.jsx)(t.h5,{id:"handling-out-of-order-samples-in-prometheus-metric-collection",children:"Handling out-of-order samples in Prometheus metric collection"}),"\n",(0,n.jsx)(t.p,{children:"Consider the following scenario in the architecture below:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"ADOT Collector Gateway batching pressure",src:o(37828).A+"",width:"841",height:"531"})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Assume that metrics from ",(0,n.jsx)(t.strong,{children:"ADOT Collector-1"})," in the Amazon EKS Cluster are sent to the Gateway cluster, which is being directed to the ",(0,n.jsx)(t.strong,{children:"Gateway ADOT Collector-1"})]}),"\n",(0,n.jsxs)(t.li,{children:["In a moment, the metrics from the same ",(0,n.jsx)(t.strong,{children:"ADOT Collector-1"})," (which is collecting the same targets, hence the same metric samples are being dealt with) is being sent to ",(0,n.jsx)(t.strong,{children:"Gateway ADOT Collector-2"})]}),"\n",(0,n.jsxs)(t.li,{children:["Now if the ",(0,n.jsx)(t.strong,{children:"Gateway ADOT Collector-2"})," happens to dispatch the metrics to Amazon Managed Service for Prometheus workspace first and then followed by the ",(0,n.jsx)(t.strong,{children:"Gateway ADOT Collector-1"})," which contains older samples for the same metrics series, you will receive the ",(0,n.jsx)(t.code,{children:"out of order sample"})," error from Amazon Managed Service for Prometheus."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"See example error below:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:'Error message:\n 2023-03-02T21:18:54.447Z        error   exporterhelper/queued_retry.go:394      Exporting failed. The error is not retryable. Dropping data.    {"kind": "exporter", "data_type": "metrics", "name": "prometheusremotewrite", "error": "Permanent error: Permanent error: remote write returned HTTP status 400 Bad Request; err = %!w(<nil>): user=820326043460_ws-5f42c3b6-3268-4737-b215-1371b55a9ef2: err: out of order sample. timestamp=2023-03-02T21:17:59.782Z, series={__name__=\\"otelcol_exporter_send_failed_metric_points\\", exporter=\\"logging\\", http_scheme=\\"http\\", instance=\\"10.195.158.91:28888\\", ", "dropped_items": 6474}\ngo.opentelemetry.io/collector/exporter/exporterhelper.(*retrySender).send\n        go.opentelemetry.io/collector@v0.66.0/exporter/exporterhelper/queued_retry.go:394\ngo.opentelemetry.io/collector/exporter/exporterhelper.(*metricsSenderWithObservability).send\n        go.opentelemetry.io/collector@v0.66.0/exporter/exporterhelper/metrics.go:135\ngo.opentelemetry.io/collector/exporter/exporterhelper.(*queuedRetrySender).start.func1\n        go.opentelemetry.io/collector@v0.66.0/exporter/exporterhelper/queued_retry.go:205\ngo.opentelemetry.io/collector/exporter/exporterhelper/internal.(*boundedMemoryQueue).StartConsumers.func1\n        go.opentelemetry.io/collector@v0.66.0/exporter/exporterhelper/internal/bounded_memory_queue.go:61\n'})}),"\n",(0,n.jsx)(t.h6,{id:"solving-out-of-order-sample-error",children:"Solving out of order sample error"}),"\n",(0,n.jsx)(t.p,{children:"You can solve the out of order sample error in this particular setup in a couple of ways:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Use a sticky load balancer to direct requests from a particular source to go to the same target based on IP address."}),"\n",(0,n.jsxs)(t.p,{children:["Refer to the ",(0,n.jsx)(t.a,{href:"https://aws.amazon.com/premiumsupport/knowledge-center/elb-route-requests-with-source-ip-alb/",children:"link here"})," for additional details."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"As an alternate option, you can add an external label in the Gateway Collectors to distinguish the metric series so Amazon Managed Service for Prometheus considers these metrics are individual metric series and are not from the same."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{type:"warning",children:(0,n.jsxs)(t.p,{children:["Using this solution can will result in multiplying the metric series in proportion to the Gateway Collectors in the setup. This is might mean that you can overrun some limits such as ",(0,n.jsx)(t.a,{href:"https://docs.aws.amazon.com/prometheus/latest/userguide/AMP_quotas.html",children:(0,n.jsx)(t.code,{children:"Active time series limits"})})]})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"If you are deploying ADOT Collector as a Daemonset"}),": make sure you are using ",(0,n.jsx)(t.code,{children:"relabel_configs"})," to only keep samples from the same node where each ADOT Collector pod is running. Check the links below to learn more.","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://aws-otel.github.io/docs/getting-started/adot-eks-add-on/config-advanced",children:"Advanced Collector Configuration for Amazon Managed Prometheus"})," - Expand the ",(0,n.jsx)(t.em,{children:"Click to View"})," section, and look for the entried similar to the following:","\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-yaml",children:"    relabel_configs:\n    - action: keep\n      regex: $K8S_NODE_NAME\n"})}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://aws-otel.github.io/docs/getting-started/adot-eks-add-on/add-on-configuration",children:"ADOT Add-On Advanced Configuration"})," - Learn how to deploy ADOT Collector using the ADOT Add-On for EKS advanced configurations."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://aws-otel.github.io/docs/getting-started/adot-eks-add-on/installation#deploy-the-adot-collector",children:"ADOT Collector deployment strategies"})," - Learn more about the different alternatives to deploy ADOT Collector at scale and the advantages of each approach."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"open-agent-management-protocol-opamp",children:"Open Agent Management Protocol (OpAMP)"}),"\n",(0,n.jsx)(t.p,{children:'OpAMP is a client/server protocol that supports communication over HTTP and over WebSockets. OpAMP is implemented in the OTel Collector and hence the OTel Collector can be used as a server as part of the control plane to manage other agents that support OpAMP, like the OTel Collector itself. The "manage" portion here involves being able to update configurations for collectors, monitoring health or even upgrading the Collectors.'}),"\n",(0,n.jsxs)(t.p,{children:["The details of this protocol is well ",(0,n.jsx)(t.a,{href:"https://opentelemetry.io/docs/collector/management/",children:"documented in the upstream OpenTelemetry website."})]}),"\n",(0,n.jsx)(t.h3,{id:"horizontal-scaling",children:"Horizontal Scaling"}),"\n",(0,n.jsx)(t.p,{children:"It may become necessary to horizontally scale an ADOT Collector depending on your workload. The requirement to horizontally scale is entirely dependent on your use case, Collector configuration, and\ntelemetry throughput."}),"\n",(0,n.jsx)(t.p,{children:"Platform specific horizontal scaling techniques can be applied to a Collector as you would any other application while being cognizant of stateful, stateless, and scraper Collector components."}),"\n",(0,n.jsxs)(t.p,{children:["Most collector components are ",(0,n.jsx)(t.code,{children:"stateless"}),", meaning that they do not hold state in memory, and if they do it is not relevant for scaling purposes. Additional replicas of stateless Collectors can be scaled behind an\napplication load balancer."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"Stateful"})," Collector components are collector components that retain information in memory which is crucial for the operation of that component."]}),"\n",(0,n.jsx)(t.p,{children:"Examples of stateful components in the ADOT Collector include but are not limited to:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/tailsamplingprocessor",children:"Tail Sampling Processor"})," - requires all spans for a trace to make an accurate sampling decisions. Avanced sampling scaling techniques is ",(0,n.jsx)(t.a,{href:"https://aws-otel.github.io/docs/getting-started/advanced-sampling",children:"documented on the ADOT developer portal"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/awsemfexporter",children:"AWS EMF Exporter"})," - performs cummulative to delta conversions on some metric types. This conversion requires the previous metric value to be stored in memory."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/processor/cumulativetodeltaprocessor#cumulative-to-delta-processor",children:"Cummulative to Delta Processor"})," - cummulative to delta conversion requires storing the previous metric value in memory."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Collector components that are ",(0,n.jsx)(t.code,{children:"scrapers"})," actively obtain telemetry data rather than passively receive it. Currently, the ",(0,n.jsx)(t.a,{href:"https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/prometheusreceiver",children:"Prometheus receiver"})," is the only scraper\ntype component in the ADOT Collector. Horizontally scaling a collector configuration that contains a prometheus receiver will require splitting the scraping jobs per collector to ensure\nthat no two Collectors scrape the same endpoint. Failure to do this may lead to Prometheus out of order sample errors."]}),"\n",(0,n.jsxs)(t.p,{children:["The process of and techniques of scaling collectors is ",(0,n.jsx)(t.a,{href:"https://opentelemetry.io/docs/collector/scaling/",children:"documunted in greater detail in the upstream OpenTelemetry website"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},54682:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/adot-collector-deployment-deployment-1ee93ef82de431619a70cc04486aca30.png"},98672:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/adot-collector-deployment-ecs-b0d7e3d9a570c3c47b96544a2f9f451c.png"},450:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/adot-collector-deployment-gateway-batching-pressure-3df82da0813ea492acb62d86ce151217.png"},37828:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/adot-collector-deployment-gateway-batching-7d623347309a82aea25ab9cbd9eb5552.png"},37957:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/adot-collector-deployment-gateway-7b89190cb3c31a2e3883885b0df572a7.png"},7872:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/adot-collector-deployment-no-collector-999d5d3495ed9914d29593b8acc5db7c.png"},18354:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/adot-collector-deployment-simple-gateway-pressure-176e7f7853aef0c791d53bc119860d42.png"},90804:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/adot-collector-deployment-simple-gateway-a47d0f8adfc55829b471b1290391279e.png"},17433:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/adot-collector-eks-daemonset-1fafe074d6b58e68da18cd163138d70e.png"},38940:(e,t,o)=>{o.d(t,{A:()=>n});const n=o.p+"assets/images/adot-collector-eks-sidecar-97f88928e556e84a5d69a91a04aa0678.png"},28453:(e,t,o)=>{o.d(t,{R:()=>i,x:()=>l});var n=o(96540);const r={},s=n.createContext(r);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);