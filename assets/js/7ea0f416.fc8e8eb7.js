"use strict";(self.webpackChunkobservability_best_practices=self.webpackChunkobservability_best_practices||[]).push([[1167],{28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var n=i(96540);const r={},s=n.createContext(r);function a(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:t},e.children)}},47496:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"guides/dotnet/open-source/metrics","title":"Metrics","description":".NET has embraced OpenTelemetry as the standard for application observability, with metrics being a key pillar alongside traces and logs. This integration enables developers to monitor application performance with minimal overhead.","source":"@site/docs/guides/dotnet/open-source/metrics.md","sourceDirName":"guides/dotnet/open-source","slug":"/guides/dotnet/open-source/metrics","permalink":"/observability-best-practices/guides/dotnet/open-source/metrics","draft":false,"unlisted":false,"editUrl":"https://github.com/aws-observability/observability-best-practices/blob/main/docusaurus/docs/guides/dotnet/open-source/metrics.md","tags":[],"version":"current","frontMatter":{}}');var r=i(74848),s=i(28453);const a={},o="Metrics",c={},l=[{value:"Metrics Implementation",id:"metrics-implementation",level:2},{value:"Custom Metrics",id:"custom-metrics",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"metrics",children:"Metrics"})}),"\n",(0,r.jsx)(t.p,{children:".NET has embraced OpenTelemetry as the standard for application observability, with metrics being a key pillar alongside traces and logs. This integration enables developers to monitor application performance with minimal overhead."}),"\n",(0,r.jsx)(t.p,{children:"In the .NET ecosystem, OpenTelemetry metrics provide a standardized approach to measuring and exposing application metrics. Starting with .NET 6 and significantly enhanced in .NET 8, the framework offers built-in support for collecting and exporting metric data."}),"\n",(0,r.jsx)(t.p,{children:"The framework provides automatic instrumentation for common components like ASP.NET Core, HTTP clients, and Entity Framework, collecting valuable metrics without additional code."}),"\n",(0,r.jsx)(t.p,{children:"OpenTelemetry in .NET supports multiple export formats, with Prometheus being particularly popular for metrics. This flexibility allows teams to integrate with their preferred observability platforms while maintaining a consistent collection approach."}),"\n",(0,r.jsx)(t.p,{children:"By adopting OpenTelemetry metrics, .NET applications benefit from a vendor-neutral, standardized approach to monitoring that scales from development environments to complex production deployments, providing crucial visibility into application health and performance."}),"\n",(0,r.jsx)(t.h2,{id:"metrics-implementation",children:"Metrics Implementation"}),"\n",(0,r.jsx)(t.p,{children:"Implementing OpenTelemetry metrics in .NET 8 applications has become remarkably straightforward. The configuration process leverages the dependency injection system that's central to modern .NET applications. Developers can configure metrics collection during the application bootstrap process using a fluent API that makes the intent clear and configuration options discoverable:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c#",children:"var builder = WebApplication.CreateBuilder(args);\n\n// Add OpenTelemetry metrics\nbuilder.Services.AddOpenTelemetry()\n    .WithMetrics(metrics => metrics\n        .AddAspNetCoreInstrumentation()\n        .AddHttpClientInstrumentation()\n        .AddRuntimeInstrumentation()\n        .AddOtlpExporter());\n"})}),"\n",(0,r.jsx)(t.h2,{id:"custom-metrics",children:"Custom Metrics"}),"\n",(0,r.jsx)(t.p,{children:"Developers can create custom metrics using the System.Diagnostics.Metrics namespace:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c#",children:'using var meter = new Meter("MyApplication.Metrics");\nvar orderCounter = meter.CreateCounter<int>("orders.processed");\n\n// Recording values\norderCounter.Add(1, new("customer", customerId));\n'})}),"\n",(0,r.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(t.p,{children:"Now that your application is instrumented, use a collector agent\u2014such as the OpenTelemetry Collector, CloudWatch Agent, or Fluent Bit\u2014to route metrics to the observability backend of your choice. Refer to the links below for details and implementation guidance."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://aws-observability.github.io/observability-best-practices/patterns/otel",children:"Observability with OpenTelemetry"})," - Comprehensive guide to implementing OpenTelemetry across your applications, providing patterns for collecting, processing, and visualizing telemetry data with AWS services to achieve full-stack observability."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://aws-observability.github.io/observability-best-practices/guides/operational/adot-at-scale/operating-adot-collector",children:"Operating the AWS Distro for OpenTelemetry (ADOT) Collector"})," - Practical guidance for deploying, scaling, and managing the ADOT Collector in production environments, including configuration best practices and integration with AWS observability services."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Install-CloudWatch-Agent.html",children:"Collect metrics, logs, and traces with the CloudWatch agent"})," - Step-by-step instructions for installing and configuring the CloudWatch agent to collect telemetry data from your applications and infrastructure, with seamless integration into AWS CloudWatch."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://github.com/aws/aws-for-fluent-bit?tab=readme-ov-file",children:"AWS for Fluent Bit"})," - Lightweight and efficient solution for collecting and forwarding logs, metrics, and traces to multiple AWS services, optimized for containerized environments and Kubernetes deployments."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format.html",children:"CloudWatch EMF"})," -Specification for embedding metric data in log events, allowing you to extract and visualize metrics from application logs without requiring a separate metrics pipeline, ideal for serverless and containerized applications."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://aws.amazon.com/blogs/mt/amazon-managed-grafana-getting-started/",children:"Amazon Managed Grafana \u2013 Getting Started"})," - Tutorial for setting up Amazon Managed Grafana to create powerful visualizations of your metrics data, with step-by-step instructions for configuring data sources, creating dashboards, and implementing alerts."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);