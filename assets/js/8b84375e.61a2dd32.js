"use strict";(self.webpackChunkobservability_best_practices=self.webpackChunkobservability_best_practices||[]).push([[9613],{95820:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var n=t(74848),s=t(28453);const o={},i="Auto-scaling Amazon EC2 using Amazon Managed Service for Prometheus and alert manager",r={id:"recipes/recipes/as-ec2-using-amp-and-alertmanager",title:"Auto-scaling Amazon EC2 using Amazon Managed Service for Prometheus and alert manager",description:"Customers want to migrate their existing Prometheus workloads to the cloud and utilize all that the cloud offers. AWS has services like Amazon EC2 Auto Scaling, which lets you scale out Amazon Elastic Compute Cloud (Amazon EC2) instances based on metrics like CPU or memory utilization. Applications that use Prometheus metrics can easily integrate into EC2 Auto Scaling without needing to replace their monitoring stack. In this post, I will walk you through configuring Amazon EC2 Auto Scaling to work with Amazon Managed Service for Prometheus Alert Manager. This approach lets you move a Prometheus-based workload to the cloud while taking advantage of services like autoscaling.",source:"@site/docs/recipes/recipes/as-ec2-using-amp-and-alertmanager.md",sourceDirName:"recipes/recipes",slug:"/recipes/recipes/as-ec2-using-amp-and-alertmanager",permalink:"/observability-best-practices/docs/recipes/recipes/as-ec2-using-amp-and-alertmanager",draft:!1,unlisted:!1,editUrl:"https://github.com/aws-observability/observability-best-practices/docs/recipes/recipes/as-ec2-using-amp-and-alertmanager.md",tags:[],version:"current",frontMatter:{}},c={},l=[{value:"Solution overview",id:"solution-overview",level:2},{value:"Testing out the solution",id:"testing-out-the-solution",level:2},{value:"Costs",id:"costs",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.h1,{id:"auto-scaling-amazon-ec2-using-amazon-managed-service-for-prometheus-and-alert-manager",children:"Auto-scaling Amazon EC2 using Amazon Managed Service for Prometheus and alert manager"}),"\n",(0,n.jsxs)(a.p,{children:["Customers want to migrate their existing Prometheus workloads to the cloud and utilize all that the cloud offers. AWS has services like Amazon ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/ec2/autoscaling/",children:"EC2 Auto Scaling"}),", which lets you scale out ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/pm/ec2/",children:"Amazon Elastic Compute Cloud (Amazon EC2)"})," instances based on metrics like CPU or memory utilization. Applications that use Prometheus metrics can easily integrate into EC2 Auto Scaling without needing to replace their monitoring stack. In this post, I will walk you through configuring Amazon EC2 Auto Scaling to work with ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/prometheus/",children:"Amazon Managed Service for Prometheus Alert Manager"}),". This approach lets you move a Prometheus-based workload to the cloud while taking advantage of services like autoscaling."]}),"\n",(0,n.jsxs)(a.p,{children:["Amazon Managed Service for Prometheus provides support for ",(0,n.jsx)(a.a,{href:"https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-Ruler.html",children:"alerting rules"})," that use ",(0,n.jsx)(a.a,{href:"https://prometheus.io/docs/prometheus/latest/querying/basics/",children:"PromQL"}),". The ",(0,n.jsx)(a.a,{href:"https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/",children:"Prometheus alerting rules documentation"})," provides the syntax and examples of valid alerting rules. Likewise, the Prometheus alert manager documentation references both the ",(0,n.jsx)(a.a,{href:"https://prometheus.io/docs/prometheus/latest/configuration/template_reference/",children:"syntax"})," and ",(0,n.jsx)(a.a,{href:"https://prometheus.io/docs/prometheus/latest/configuration/template_examples/",children:"examples"})," of valid alert manager configurations."]}),"\n",(0,n.jsx)(a.h2,{id:"solution-overview",children:"Solution overview"}),"\n",(0,n.jsxs)(a.p,{children:["First, let\u2019s briefly review Amazon EC2 Auto Scaling\u2018s concept of an ",(0,n.jsx)(a.a,{href:"https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-groups.html",children:"Auto Scaling group"})," which is a logical collection of Amazon EC2 instances. An Auto Scaling group can launch EC2 instances based on a predefined launch template. The ",(0,n.jsx)(a.a,{href:"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html",children:"launch template"})," contains information used to launch the Amazon EC2 instance, including the AMI ID, the instance type, network settings, and ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/iam/",children:"AWS Identity and Access Management (IAM)"})," instance profile."]}),"\n",(0,n.jsxs)(a.p,{children:["Amazon EC2 Auto Scaling groups have a ",(0,n.jsx)(a.a,{href:"https://docs.aws.amazon.com/autoscaling/ec2/userguide/what-is-amazon-ec2-auto-scaling.html",children:"minimum size, maximum size, and desired capacity"})," concepts. When Amazon EC2 Auto Scaling detects that the current running capacity of the Auto Scaling group is above or below the desired capacity, it will automatically scale out or scale in as needed. This scaling approach lets you utilize elasticity within your workload while still keeping bounds on both capacity and costs."]}),"\n",(0,n.jsxs)(a.p,{children:["To demonstrate this solution, I have created an Amazon EC2 Auto Scaling group that contains two Amazon EC2 instances. These instances ",(0,n.jsx)(a.a,{href:"https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-onboard-ingest-metrics-remote-write-EC2.html",children:"remote write instance metrics"})," to an Amazon Managed Service for Prometheus workspace. I have set the Auto Scaling group\u2019s minimum size to two (to maintain high availability), and I\u2019ve set the group\u2019s maximum size to 10 (to help control costs). As more traffic hits the solution, additional Amazon EC2 instances are automatically added to support the load, up to the Amazon EC2 Auto Scaling group\u2019s maximum size. As the load decreases, those Amazon EC2 instances are terminated until the Amazon EC2 Auto Scaling group reaches the group\u2019s minimum size. This approach lets you have a performant application by utilizing the elasticity of the cloud."]}),"\n",(0,n.jsx)(a.p,{children:"Note that as you scrape more and more resources, you could quickly overwhelm the capabilities of a single Prometheus server. You can avoid this situation by scaling Prometheus servers linearly with the workload. This approach ensures that you can collect metric data at the granularity that you want."}),"\n",(0,n.jsx)(a.p,{children:"To support the Auto Scaling of a Prometheus workload, I have created an Amazon Managed Service for Prometheus workspace with the following rules:"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.code,{children:"YAML"})}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{children:'groups:\n- name: example\n  rules:\n  - alert: HostHighCpuLoad\n    expr: 100 - (avg(rate(node_cpu_seconds_total{mode="idle"}[2m])) * 100) > 60\n    for: 5m\n    labels:\n      severity: warning\n      event_type: scale_up\n    annotations:\n      summary: Host high CPU load (instance {{ $labels.instance }})\n      description: "CPU load is > 60%\\n  VALUE = {{ $value }}\\n  LABELS = {{ $labels }}"\n  - alert: HostLowCpuLoad\n    expr: 100 - (avg(rate(node_cpu_seconds_total{mode="idle"}[2m])) * 100) < 30\n    for: 5m\n    labels:\n      severity: warning\n      event_type: scale_down\n    annotations:\n      summary: Host low CPU load (instance {{ $labels.instance }})\n      description: "CPU load is < 30%\\n  VALUE = {{ $value }}\\n  LABELS = {{ $labels }}"\n\n'})}),"\n",(0,n.jsxs)(a.p,{children:["This rules set creates a ",(0,n.jsx)(a.code,{children:"HostHighCpuLoad"})," and a ",(0,n.jsx)(a.code,{children:"HostLowCpuLoad"})," rules. These alerts trigger when the CPU is greater than 60% or less than 30% utilization over a five-minute period."]}),"\n",(0,n.jsxs)(a.p,{children:["After raising an alert, the alert manager will forward the message into an Amazon SNS topic, passing an ",(0,n.jsx)(a.code,{children:"alert_type"})," (the alert name) and ",(0,n.jsx)(a.code,{children:"event_type"})," (scale_down or scale_up)."]}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.code,{children:"YAML"})}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{children:"alertmanager_config: |\n  route: \n    receiver: default_receiver\n    repeat_interval: 5m\n        \n  receivers:\n    - name: default_receiver\n      sns_configs:\n        - topic_arn: <ARN OF SNS TOPIC GOES HERE>\n          send_resolved: false\n          sigv4:\n            region: us-east-1\n          message: |\n            alert_type: {{ .CommonLabels.alertname }}\n            event_type: {{ .CommonLabels.event_type }}\n\n"})}),"\n",(0,n.jsxs)(a.p,{children:["An AWS ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/lambda/",children:"Lambda"})," function is subscribed to the Amazon SNS topic. I have written logic in the Lambda function to inspect the Amazon SNS message and determine if a ",(0,n.jsx)(a.code,{children:"scale_up"})," or ",(0,n.jsx)(a.code,{children:"scale_down"})," event should happen. Then, the Lambda function increments or decrements the desired capacity of the Amazon EC2 Auto Scaling group. The Amazon EC2 Auto Scaling group detects a requested change in capacity, and then invokes or deallocates Amazon EC2 instances."]}),"\n",(0,n.jsx)(a.p,{children:"The Lambda code to support Auto Scaling is as follows:"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.code,{children:"Python"})}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{children:"import json\nimport boto3\nimport os\n\ndef lambda_handler(event, context):\n    print(event)\n    msg = event['Records'][0]['Sns']['Message']\n    \n    scale_type = ''\n    if msg.find('scale_up') > -1:\n        scale_type = 'scale_up'\n    else:\n        scale_type = 'scale_down'\n    \n    get_desired_instance_count(scale_type)\n    \ndef get_desired_instance_count(scale_type):\n    \n    client = boto3.client('autoscaling')\n    asg_name = os.environ['ASG_NAME']\n    response = client.describe_auto_scaling_groups(AutoScalingGroupNames=[ asg_name])\n\n    minSize = response['AutoScalingGroups'][0]['MinSize']\n    maxSize = response['AutoScalingGroups'][0]['MaxSize']\n    desiredCapacity = response['AutoScalingGroups'][0]['DesiredCapacity']\n    \n    if scale_type == \"scale_up\":\n        desiredCapacity = min(desiredCapacity+1, maxSize)\n    if scale_type == \"scale_down\":\n        desiredCapacity = max(desiredCapacity - 1, minSize)\n    \n    print('Scale type: {}; new capacity: {}'.format(scale_type, desiredCapacity))\n    response = client.set_desired_capacity(AutoScalingGroupName=asg_name, DesiredCapacity=desiredCapacity, HonorCooldown=False)\n\n"})}),"\n",(0,n.jsx)(a.p,{children:"The full architecture can be reviewed in the following figure."}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"Architecture",src:t(75681).A+"",width:"1411",height:"1081"})}),"\n",(0,n.jsx)(a.h2,{id:"testing-out-the-solution",children:"Testing out the solution"}),"\n",(0,n.jsx)(a.p,{children:"You can launch an AWS CloudFormation template to automatically provision this solution."}),"\n",(0,n.jsx)(a.p,{children:"Stack prerequisites:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:["An ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/vpc/",children:"Amazon Virtual Private Cloud (Amazon VPC)"})]}),"\n",(0,n.jsx)(a.li,{children:"An AWS Security Group that allows outbound traffic"}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"Select the Download Launch Stack Template link to download and set up the template in your account. As part of the configuration process, you must specify the subnets and the security groups that you want associated with the Amazon EC2 instances. See the following figure for details."}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.a,{href:"https://prometheus-autoscale.s3.amazonaws.com/prometheus-autoscale.template",children:"## Download Launch Stack Template "})}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"Launch Stack",src:t(77198).A+"",width:"1415",height:"1315"})}),"\n",(0,n.jsx)(a.p,{children:"This is the CloudFormation stack details screen, where the stack name has been set as prometheus-autoscale. The stack parameters include a URL of the Linux installer for Prometheus, the URL for the Linux Node Exporter for Prometheus, the subnets and security groups used in the solution, the AMI and instance type to use, and the maximum capacity of the Amazon EC2 Auto Scaling group."}),"\n",(0,n.jsxs)(a.p,{children:["The stack will take approximately eight minutes to deploy. Once complete, you will find two Amazon EC2 instances that have been deployed and are running in the Amazon EC2 Auto Scaling group that has been created for you. To validate that this solution auto-scales via Amazon Managed Service for Prometheus Alert Manager, you apply load to the Amazon EC2 instances using the ",(0,n.jsx)(a.a,{href:"https://docs.aws.amazon.com/systems-manager/latest/userguide/execute-remote-commands.html",children:"AWS Systems Manager Run Command"})," and the ",(0,n.jsx)(a.a,{href:"https://docs.aws.amazon.com/fis/latest/userguide/actions-ssm-agent.html#awsfis-run-cpu-stress",children:"AWSFIS-Run-CPU-Stress automation document"}),"."]}),"\n",(0,n.jsx)(a.p,{children:"As stress is applied to the CPUs in the Amazon EC2 Auto Scaling group, alert manager publishes these alerts, which the Lambda function responds to by scaling up the Auto Scaling group.  As CPU consumption decreases, the low CPU alert in the Amazon Managed Service for Prometheus workspace fires, alert manager publishes the alert to the Amazon SNS topic, and the Lambda function responds by responds by scaling down the Auto Scaling group, as demonstrated in the following figure."}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"Dashboard",src:t(76695).A+"",width:"1405",height:"702"})}),"\n",(0,n.jsx)(a.p,{children:"The Grafana dashboard has a line showing that CPU has spiked to 100%. Although the CPU is high, another line shows that the number of instances has stepped up from 2 to 10. Once CPU has decreased, the number of instances slowly decreases back down to 2."}),"\n",(0,n.jsx)(a.h2,{id:"costs",children:"Costs"}),"\n",(0,n.jsxs)(a.p,{children:["Amazon Managed Service for Prometheus is priced based on the metrics ingested, metrics stored, and metrics queried. Visit the ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/prometheus/pricing/",children:"Amazon Managed Service for Prometheus pricing page"})," for the latest pricing and pricing examples."]}),"\n",(0,n.jsxs)(a.p,{children:["Amazon SNS is priced based on the number of monthly API requests made. Message delivery between Amazon SNS and Lambda is free, but it does charge for the amount of data transferred between Amazon SNS and Lambda. See the ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/sns/pricing/",children:"latest Amazon SNS pricing details"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["Lambda is priced based on the duration of your function execution and the number of requests made to the function. See the latest ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/lambda/pricing/",children:"AWS Lambda pricing details"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["There are ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/ec2/autoscaling/pricing/",children:"no additional charges for using"})," Amazon EC2 Auto Scaling."]}),"\n",(0,n.jsx)(a.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsx)(a.p,{children:"By using Amazon Managed Service for Prometheus, alert manager, Amazon SNS, and Lambda, you can control the scaling activities of an Amazon EC2 Auto Scaling group. The solution in this post demonstrates how you can move existing Prometheus workloads to AWS, while also utilizing Amazon EC2 Auto Scaling. As load increases to the application, it seamlessly scales to meet demand."}),"\n",(0,n.jsx)(a.p,{children:"In this example, the Amazon EC2 Auto Scaling group scaled based on CPU, but you can follow a similar approach for any Prometheus metric from your workload. This approach provides fine-grained control over scaling actions, thereby making sure that you can scale your workload on the metric that provides the most business value."}),"\n",(0,n.jsxs)(a.p,{children:["In previous blog posts, we\u2019ve also demonstrated how you can use ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/blogs/mt/using-amazon-managed-service-for-prometheus-alert-manager-to-receive-alerts-with-pagerduty/",children:"Amazon Managed Service for Prometheus Alert Manager to receive alerts with PagerDuty"})," and ",(0,n.jsx)(a.a,{href:"https://aws.amazon.com/blogs/mt/how-to-integrate-amazon-managed-service-for-prometheus-with-slack/",children:"how to integrate Amazon Managed Service for Prometheus with Slack"}),". These solutions show how you can receive alerts from your workspace in the way that is most useful to you."]}),"\n",(0,n.jsxs)(a.p,{children:["For next steps, see how to ",(0,n.jsx)(a.a,{href:"https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-rules-upload.html",children:"create your own rules configuration file"})," for Amazon Managed Service for Prometheus, and set up your own ",(0,n.jsx)(a.a,{href:"https://docs.aws.amazon.com/prometheus/latest/userguide/AMP-alertmanager-receiver.html",children:"alert receiver"}),". Moreover, check out ",(0,n.jsx)(a.a,{href:"https://awesome-prometheus-alerts.grep.to/alertmanager",children:"Awesome Prometheus alerts"})," for some good examples of alerting rules that can be used within alert manager."]})]})}function u(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},75681:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/as-ec2-amp-alertmanager3-a7f7c99c80d1b4696adcea6abcaaf46e.png"},77198:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/as-ec2-amp-alertmanager4-63dab0d7230022913dfb7193f39cce88.png"},76695:(e,a,t)=>{t.d(a,{A:()=>n});const n=t.p+"assets/images/as-ec2-amp-alertmanager5-844cc9ab4fa8958fb3db3b86b52d8df5.png"},28453:(e,a,t)=>{t.d(a,{R:()=>i,x:()=>r});var n=t(96540);const s={},o=n.createContext(s);function i(e){const a=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(o.Provider,{value:a},e.children)}}}]);