"use strict";(globalThis.webpackChunkobservability_best_practices=globalThis.webpackChunkobservability_best_practices||[]).push([[3548],{32895(e,t,i){i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"guides/dotnet/oss/traces","title":"Tracing","description":".NET offers robust support for OpenTelemetry tracing, providing developers with powerful tools to monitor request flows across distributed systems. This implementation enables end-to-end visibility into application behavior and performance bottlenecks.","source":"@site/docs/guides/dotnet/oss/traces.md","sourceDirName":"guides/dotnet/oss","slug":"/guides/dotnet/oss/traces","permalink":"/observability-best-practices/guides/dotnet/oss/traces","draft":false,"unlisted":false,"editUrl":"https://github.com/aws-observability/observability-best-practices/blob/main/docusaurus/docs/guides/dotnet/oss/traces.md","tags":[],"version":"current","frontMatter":{},"sidebar":"guides","previous":{"title":"Metrics","permalink":"/observability-best-practices/guides/dotnet/oss/metrics"},"next":{"title":"OpenTelemetry with .NET","permalink":"/observability-best-practices/guides/dotnet/oss/opentelemetry"}}');var r=i(74848),s=i(28453);const o={},a="Tracing",c={},d=[{value:"Traces Implementation",id:"traces-implementation",level:2},{value:"Custom Traces",id:"custom-traces",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"tracing",children:"Tracing"})}),"\n",(0,r.jsx)(t.p,{children:".NET offers robust support for OpenTelemetry tracing, providing developers with powerful tools to monitor request flows across distributed systems. This implementation enables end-to-end visibility into application behavior and performance bottlenecks."}),"\n",(0,r.jsxs)(t.p,{children:["In the .NET ecosystem, OpenTelemetry tracing is built around the ",(0,r.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.activity?view=net-9.0",children:"System.Diagnostics.Activity"})," class, which is .NET's implementation of the W3C Trace Context specification. This alignment with industry standards ensures interoperability with other services and observability tools."]}),"\n",(0,r.jsx)(t.h2,{id:"traces-implementation",children:"Traces Implementation"}),"\n",(0,r.jsx)(t.p,{children:"Configuring OpenTelemetry tracing in a .NET application is straightforward:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c#",children:'builder.Services.AddOpenTelemetry()\n    .WithTracing(tracing => tracing\n        .AddAspNetCoreInstrumentation()\n        .AddHttpClientInstrumentation()\n        .AddEntityFrameworkCoreInstrumentation()\n        .AddSource("MyApplication.Tracing")\n        .AddOtlpExporter());\n'})}),"\n",(0,r.jsx)(t.p,{children:"A key strength of .NET's OpenTelemetry implementation is automatic instrumentation. Many common libraries and frameworks\u2014including ASP.NET Core, HttpClient, gRPC, and Entity Framework Core\u2014emit traces without requiring additional code. This provides immediate visibility into external calls and database operations."}),"\n",(0,r.jsx)(t.h2,{id:"custom-traces",children:"Custom Traces"}),"\n",(0,r.jsx)(t.p,{children:"Creating custom traces in application code uses the ActivitySource API:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c#",children:'// Create a source once and reuse it\nprivate static readonly ActivitySource MyActivitySource = \n    new("MyApplication.Tracing");\n\n// Create spans for important operations\nusing var activity = MyActivitySource.StartActivity("ProcessOrder");\nactivity?.SetTag("orderId", orderId);\n\n// Child operations create nested spans\nusing var childActivity = MyActivitySource.StartActivity("ValidatePayment");\n'})}),"\n",(0,r.jsx)(t.p,{children:"Registering your ActivitySource in dependency injection is considered a best practice for OpenTelemetry tracing in .NET applications."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c#",children:'// During service configuration\nservices.AddSingleton(sp => new ActivitySource("MyCompany.MyApplication", "1.0.0"));\n\n// Or create a wrapper service if you need more functionality\nservices.AddSingleton<TracingService>();\n\n// Then inject it where needed\npublic class OrderProcessor\n{\n    private readonly ActivitySource _activitySource;\n    \n    public OrderProcessor(ActivitySource activitySource)\n    {\n        _activitySource = activitySource;\n    }\n    \n    public void ProcessOrder(Order order)\n    {\n        using var activity = _activitySource.StartActivity("ProcessOrder");\n        activity?.SetTag("orderId", order.Id);\n        \n        // Processing logic\n    }\n}\n'})})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453(e,t,i){i.d(t,{R:()=>o,x:()=>a});var n=i(96540);const r={},s=n.createContext(r);function o(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);