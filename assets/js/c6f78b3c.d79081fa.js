"use strict";(self.webpackChunkobservability_best_practices=self.webpackChunkobservability_best_practices||[]).push([[7165],{26603:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"guides/dotnet/oss/metrics","title":"Metrics","description":".NET has embraced OpenTelemetry as the standard for application observability, with metrics being a key pillar alongside traces and logs. This integration enables developers to monitor application performance with minimal overhead.","source":"@site/docs/guides/dotnet/oss/metrics.md","sourceDirName":"guides/dotnet/oss","slug":"/guides/dotnet/oss/metrics","permalink":"/observability-best-practices/guides/dotnet/oss/metrics","draft":false,"unlisted":false,"editUrl":"https://github.com/aws-observability/observability-best-practices/blob/main/docusaurus/docs/guides/dotnet/oss/metrics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"guides","previous":{"title":"Logs","permalink":"/observability-best-practices/guides/dotnet/oss/logs"},"next":{"title":"Tracing","permalink":"/observability-best-practices/guides/dotnet/oss/traces"}}');var r=i(74848),s=i(28453);const o={},a="Metrics",c={},l=[{value:"Metrics Implementation",id:"metrics-implementation",level:2},{value:"Custom Metrics",id:"custom-metrics",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"metrics",children:"Metrics"})}),"\n",(0,r.jsx)(t.p,{children:".NET has embraced OpenTelemetry as the standard for application observability, with metrics being a key pillar alongside traces and logs. This integration enables developers to monitor application performance with minimal overhead."}),"\n",(0,r.jsx)(t.p,{children:"In the .NET ecosystem, OpenTelemetry metrics provide a standardized approach to measuring and exposing application metrics. Starting with .NET 6 and significantly enhanced in .NET 8, the framework offers built-in support for collecting and exporting metric data."}),"\n",(0,r.jsx)(t.p,{children:"The framework provides automatic instrumentation for common components like ASP.NET Core, HTTP clients, and Entity Framework, collecting valuable metrics without additional code."}),"\n",(0,r.jsx)(t.p,{children:"OpenTelemetry in .NET supports multiple export formats, with Prometheus being particularly popular for metrics. This flexibility allows teams to integrate with their preferred observability platforms while maintaining a consistent collection approach."}),"\n",(0,r.jsx)(t.p,{children:"By adopting OpenTelemetry metrics, .NET applications benefit from a vendor-neutral, standardized approach to monitoring that scales from development environments to complex production deployments, providing crucial visibility into application health and performance."}),"\n",(0,r.jsx)(t.h2,{id:"metrics-implementation",children:"Metrics Implementation"}),"\n",(0,r.jsx)(t.p,{children:"Implementing OpenTelemetry metrics in .NET 8 applications has become remarkably straightforward. The configuration process leverages the dependency injection system that's central to modern .NET applications. Developers can configure metrics collection during the application bootstrap process using a fluent API that makes the intent clear and configuration options discoverable:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c#",children:"var builder = WebApplication.CreateBuilder(args);\n\n// Add OpenTelemetry metrics\nbuilder.Services.AddOpenTelemetry()\n    .WithMetrics(metrics => metrics\n        .AddAspNetCoreInstrumentation()\n        .AddHttpClientInstrumentation()\n        .AddRuntimeInstrumentation()\n        .AddOtlpExporter());\n"})}),"\n",(0,r.jsx)(t.h2,{id:"custom-metrics",children:"Custom Metrics"}),"\n",(0,r.jsx)(t.p,{children:"Developers can create custom metrics using the System.Diagnostics.Metrics namespace:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-c#",children:'using var meter = new Meter("MyApplication.Metrics");\nvar orderCounter = meter.CreateCounter<int>("orders.processed");\n\n// Recording values\norderCounter.Add(1, new("customer", customerId));\n'})})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>a});var n=i(96540);const r={},s=n.createContext(r);function o(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);