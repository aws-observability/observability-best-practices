"use strict";(self.webpackChunkobservability_best_practices=self.webpackChunkobservability_best_practices||[]).push([[7231],{38613:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var n=s(74848),i=s(28453);const a={},o="Amazon EKS API Server Monitoring",r={id:"guides/containers/aws-native/eks/eks-api-server-monitoring",title:"Amazon EKS API Server Monitoring",description:"In this section of Observability best practices guide, we will deep dive on to following topics related to API Server Monitoring:",source:"@site/docs/guides/containers/aws-native/eks/eks-api-server-monitoring.md",sourceDirName:"guides/containers/aws-native/eks",slug:"/guides/containers/aws-native/eks/eks-api-server-monitoring",permalink:"/observability-best-practices/docs/guides/containers/aws-native/eks/eks-api-server-monitoring",draft:!1,unlisted:!1,editUrl:"https://github.com/aws-observability/observability-best-practices/docs/guides/containers/aws-native/eks/eks-api-server-monitoring.md",tags:[],version:"current",frontMatter:{},sidebar:"guides",previous:{title:"Log Aggregation",permalink:"/observability-best-practices/docs/guides/containers/aws-native/eks/log-aggregation"},next:{title:"Container Tracing with AWS X-Ray",permalink:"/observability-best-practices/docs/guides/containers/aws-native/eks/container-tracing-with-aws-xray"}},l={},h=[{value:"Introduction",id:"introduction",level:3},{value:"Setting up an API Server Troubleshooter Dashboard",id:"setting-up-an-api-server-troubleshooter-dashboard",level:3},{value:"Using API Troubleshooter Dashboard to Understand Problems",id:"using-api-troubleshooter-dashboard-to-understand-problems",level:3},{value:"Understanding LIST vs. WATCH",id:"understanding-list-vs-watch",level:4},{value:"A well-behaved WATCH",id:"a-well-behaved-watch",level:4},{value:"Understanding Unbounded list calls to API Server",id:"understanding-unbounded-list-calls-to-api-server",level:3},{value:"Stopping bad behavior to API Server",id:"stopping-bad-behavior-to-api-server",level:3},{value:"API Priority and Fairness",id:"api-priority-and-fairness",level:3},{value:"Priority and fairness in action",id:"priority-and-fairness-in-action",level:4},{value:"Percent in use",id:"percent-in-use",level:4},{value:"Time request was in queue",id:"time-request-was-in-queue",level:4},{value:"Top executed requests by flow",id:"top-executed-requests-by-flow",level:4},{value:"Request Execution Time",id:"request-execution-time",level:4},{value:"Identifying slowest API calls and API Server Latency Issues",id:"identifying-slowest-api-calls-and-api-server-latency-issues",level:3},{value:"Slowest API call",id:"slowest-api-call",level:4},{value:"API Request Duration",id:"api-request-duration",level:4},{value:"ETCD Request Duration",id:"etcd-request-duration",level:4},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"amazon-eks-api-server-monitoring",children:"Amazon EKS API Server Monitoring"}),"\n",(0,n.jsx)(t.p,{children:"In this section of Observability best practices guide, we will deep dive on to following topics related to API Server Monitoring:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Introduction to Amazon EKS API Server Monitoring"}),"\n",(0,n.jsx)(t.li,{children:"Setting up an API Server Troubleshooter Dashboard"}),"\n",(0,n.jsx)(t.li,{children:"Using API Troubleshooter Dashboard to Understand API Server Problems"}),"\n",(0,n.jsx)(t.li,{children:"Understanding Unbounded list calls to API Server"}),"\n",(0,n.jsx)(t.li,{children:"Stopping bad behavior to API Server"}),"\n",(0,n.jsx)(t.li,{children:"API Priority and Fairness"}),"\n",(0,n.jsx)(t.li,{children:"Identifying slowest API calls and API Server Latency Issues"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"introduction",children:"Introduction"}),"\n",(0,n.jsx)(t.p,{children:"Monitoring your Amazon EKS managed control plane is a very important Day 2 operational activity to proactively identity issues with health of your EKS cluster. Amazon EKS Control plane monitoring helps you to take proactive measures based on the collected metrics. These metrics would helps us to troubleshoot the API servers and pin point the problem under the hood."}),"\n",(0,n.jsxs)(t.p,{children:["We will be using Amazon Managed Service for Prometheus (AMP) for our demonstration in this section for Amazon EKS API server monitoring and Amazon Managed Grafana (AMG) for visualization of metrics. Prometheus is a popular open source monitoring tool that provides powerful querying features and has wide support for a variety of workloads. Amazon Managed Service for Prometheus is a fully managed Prometheus-compatible service that makes it easier to monitor environments, such as Amazon EKS, ",(0,n.jsx)(t.a,{href:"http://aws.amazon.com/ecs",children:"Amazon Elastic Container Service (Amazon ECS)"}),", and ",(0,n.jsx)(t.a,{href:"http://aws.amazon.com/ec2",children:"Amazon Elastic Compute Cloud (Amazon EC2)"}),", securely and reliably. ",(0,n.jsx)(t.a,{href:"https://aws.amazon.com/grafana/",children:"Amazon Managed Grafana"})," is a fully managed and secure data visualization service for open source Grafana that enables customers to instantly query, correlate, and visualize operational metrics, logs, and traces for their applications from multiple data sources"]}),"\n",(0,n.jsxs)(t.p,{children:["We will first setup a starter dashboard using Amazon Managed Service for Prometheus and Amazon Managed Grafana to help you with troubleshooting ",(0,n.jsx)(t.a,{href:"https://aws.amazon.com/eks",children:"Amazon Elastic Kubernetes Service (Amazon EKS)"})," API Servers with Prometheus. We will diving deep in up coming sections around understanding problems while troubleshooting the EKS API Servers, API priority and fairness, stopping bad behaviours. Finally we will deep dive in indentifying API calls that are slowest and API server latency issues which helps us to take actions to keep state of our Amazon EKS cluster healthy."]}),"\n",(0,n.jsx)(t.h3,{id:"setting-up-an-api-server-troubleshooter-dashboard",children:"Setting up an API Server Troubleshooter Dashboard"}),"\n",(0,n.jsxs)(t.p,{children:["We will setup a starter dashboard to help you with troubleshooting ",(0,n.jsx)(t.a,{href:"https://aws.amazon.com/eks",children:"Amazon Elastic Kubernetes Service (Amazon EKS)"})," API Servers with AMP. We will use this to help you understand the metrics while troubleshooting your production EKS clusters. We will further focus deep on the collected metrics to understand its importance while troubleshooting your Amazon EKS clusters."]}),"\n",(0,n.jsxs)(t.p,{children:["First, setup an ",(0,n.jsx)(t.a,{href:"https://aws.amazon.com/blogs/containers/metrics-and-traces-collection-using-amazon-eks-add-ons-for-aws-distro-for-opentelemetry/",children:"ADOT collector to collect metrics from your Amazon EKS cluster to Amazon Manager Service for Prometheus"}),". In this setup you will be using EKS ADOT Addon which  allows users to enable ADOT as an add-on at any time after the EKS cluster is up and running. The ADOT add-on includes the latest security patches and bug fixes and is validated by AWS to work with Amazon EKS. This setup will show you how to install the ADOT add-on in an EKS cluster and then use it to collect metrics from your cluster."]}),"\n",(0,n.jsxs)(t.p,{children:["Next, ",(0,n.jsx)(t.a,{href:"https://aws.amazon.com/blogs/mt/amazon-managed-grafana-getting-started/",children:"setup your Amazon Managed Grafana workspace to visualize metrics using AMP"})," as a data source which you have setup in the first step. Finally download the ",(0,n.jsx)(t.a,{href:"https://github.com/RiskyAdventure/Troubleshooting-Dashboards/blob/main/api-troubleshooter.json",children:"API troubleshooter dashboard"}),", navigate to Amazon Managed Grafana to upload the API troubleshooter dashboard json to visualize the metrics for further troubleshooting."]}),"\n",(0,n.jsx)(t.h3,{id:"using-api-troubleshooter-dashboard-to-understand-problems",children:"Using API Troubleshooter Dashboard to Understand Problems"}),"\n",(0,n.jsx)(t.p,{children:"Let\u2019s say you found an interesting open-source project that you wanted to install in your cluster. That operator deploys a DaemonSet to your cluster that might be using malformed requests, a needlessly high volume of LIST calls, or maybe each of its DaemonSets across all your 1,000 nodes are requesting status of all 50,000 pods on your cluster every minute!\nDoes this really happen often? Yes, it does! Let\u2019s take a quick detour on how that happens."}),"\n",(0,n.jsx)(t.h4,{id:"understanding-list-vs-watch",children:"Understanding LIST vs. WATCH"}),"\n",(0,n.jsxs)(t.p,{children:["Some applications need to understand the state of the objects in your cluster. For example, your machine learning (ML) application wants to know the job status by understanding how many pods are not in the ",(0,n.jsx)(t.em,{children:"Completed"})," status. In Kubernetes, there are well-behaved ways to do this with something called a WATCH, and some not-so-well-behaved ways that list every object on the cluster to find the latest status on those pods."]}),"\n",(0,n.jsx)(t.h4,{id:"a-well-behaved-watch",children:"A well-behaved WATCH"}),"\n",(0,n.jsx)(t.p,{children:"Using a WATCH or a single, long-lived connection to receive updates via a push model is the most scalable way to do updates in Kubernetes. To oversimplify, we ask for the full state of the system, then only update the object in a cache when changes are received for that object, periodically running a re-sync to ensure that no updates were missed."}),"\n",(0,n.jsxs)(t.p,{children:["In the below image we use the ",(0,n.jsx)(t.code,{children:"apiserver_longrunning_gauge"})," to get an idea of the number of these long-lived connections across both API servers."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-1",src:s(51930).A+"",width:"1613",height:"361"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsxs)(t.em,{children:["Figure: ",(0,n.jsx)(t.code,{children:"apiserver_longrunning_gauge"})," metric"]})}),"\n",(0,n.jsx)(t.p,{children:"Even with this efficient system, we can still have too much of a good thing. For example, if we use many very small nodes, each using two or more DaemonSets that need to talk to the API server, it is quite easy to dramatically increase the number of WATCH calls on the system unnecessarily. For example, let\u2019s look at the difference between eight xlarge nodes vs. a single 8xlarge. Here we see an 8x increase of WATCH calls on the system."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-2",src:s(78514).A+"",width:"921",height:"415"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Figure: WATCH calls between 8 xlarge nodes."})}),"\n",(0,n.jsx)(t.p,{children:"Now these are efficient calls, but what if instead they were the ill-behaved calls we alluded to earlier? Imagine if one of the above DaemonSets on each of the 1,000 nodes is requesting updates on each of the total 50,000 pods in the cluster. We will explore this idea of an unbounded list call in next section."}),"\n",(0,n.jsx)(t.p,{children:"A quick word of caution before continuing, the type of consolidation in the above example must be done with great care, and has many other factors to consider. Everything from the delay of the number of threads competing for a limited number of CPUs on the system, Pod churn rate, to the maximum number of volume attachments a node can handle safely. However, our focus will be on the metrics that lead us to actionable steps that can prevent issues from happening\u2014and maybe give us new insight into our designs."}),"\n",(0,n.jsx)(t.p,{children:"The WATCH metric is a simple one, but it can be used to track and reduce the number of watches, if that is a problem for you. Here are a few options you could consider to reduce this number:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Limit the number of ConfigMaps Helm creates to track History"}),"\n",(0,n.jsx)(t.li,{children:"Use Immutable ConfigMaps and Secrets which do not use a WATCH"}),"\n",(0,n.jsx)(t.li,{children:"Sensible node sizing and consolidation"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"understanding-unbounded-list-calls-to-api-server",children:"Understanding Unbounded list calls to API Server"}),"\n",(0,n.jsx)(t.p,{children:"Now for the LIST call we have been talking about. A list call is pulling the full history on our Kubernetes objects each time we need to understand an object\u2019s state, nothing is being saved in a cache this time."}),"\n",(0,n.jsx)(t.p,{children:"How impactful is all this? That will vary depending on how many agents are requesting data, how often they are doing so, and how much data they are requesting. Are they asking for everything on the cluster, or just a single namespace? Does that happen every minute, on very node? Let\u2019s use an example of a logging agent that is appending Kubernetes metadata on every log sent from a node. This could be an overwhelming amount of data in larger clusters. There are many ways for the agent to get that data via a list call, so let\u2019s look at a few."}),"\n",(0,n.jsx)(t.p,{children:"The below request is asking for pods from a specific namespace."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.code,{children:"/api/v1/namespaces/my-namespace/pods"})}),"\n",(0,n.jsx)(t.p,{children:"Next, we request all 50,000 pods on the cluster, but in chunks of 500 pods at a time."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.code,{children:"/api/v1/pods?limit=500"})}),"\n",(0,n.jsx)(t.p,{children:"The next call is the most disruptive. Fetching all 50,000 pods on the entire cluster at the same time."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.code,{children:"/api/v1/pods"})}),"\n",(0,n.jsx)(t.p,{children:"This happens quite commonly in the field and can be seen in the logs."}),"\n",(0,n.jsx)(t.h3,{id:"stopping-bad-behavior-to-api-server",children:"Stopping bad behavior to API Server"}),"\n",(0,n.jsxs)(t.p,{children:["How can we protect our cluster from such bad behavior? Before Kubernetes 1.20, the API server would protect itself by limiting the number of ",(0,n.jsx)(t.em,{children:"inflight"})," requests processed per second. Since etcd can only handle so many requests at one time in a performant way, we need to ensure the number of requests is limited to a value per second that keeps etcd reads and writes in a reasonable latency band. Unfortunately, at the time of this writing, there is no dynamic way to do this."]}),"\n",(0,n.jsx)(t.p,{children:"In the below chart we see a breakdown of read requests, which has a default maximum of 400 inflight request per API server and a default max of 200 concurrent write requests. In a default EKS cluster you will see two API servers for a total of 800 reads and 400 writes. However, caution is advised as these servers can have asymmetric loads on them at different times like right after an upgrade, etc."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-3",src:s(12168).A+"",width:"1292",height:"536"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Figure: Grafana chart with breakdown of read requests."})}),"\n",(0,n.jsx)(t.p,{children:"It turns out that the above was not a perfect scheme. For example, how could we keep this badly behaving new operator we just installed from taking up all the inflight write requests on the API server and potentially delaying important requests such as node keepalive messages?"}),"\n",(0,n.jsx)(t.h3,{id:"api-priority-and-fairness",children:"API Priority and Fairness"}),"\n",(0,n.jsx)(t.p,{children:"Instead of worrying about how many read/write requests were open per second, what if we treated the capacity as one total number, and each application on the cluster got a fair percentage or share of that total maximum number?"}),"\n",(0,n.jsxs)(t.p,{children:["To do that that effectively, we would need to identify who sent the request to the API server, then give that request a name tag of sorts. With this new name tag, we could then see all these requests are coming from a new agent we will call \u201cChatty.\u201d Now we can group all of Chatty\u2019s requests into something called a ",(0,n.jsx)(t.em,{children:"flow"}),", that identifies those requests are coming from the same DaemonSet. This concept now gives us the ability to restrict this bad agent and ensure it does not consume the whole cluster."]}),"\n",(0,n.jsx)(t.p,{children:"However, not all requests are created equal. The control plane traffic that is needed to keep the cluster operational should be a higher priority than our new operator. This is where the idea of priority levels comes into play. What if, by default, we had a several \u201cbuckets\u201d or queues for critical, high, and low priority traffic? We do not want the chatty agent flow getting a fair share of traffic in the critical traffic queue. We can however put that traffic in a low priority queue so that flow is competing with perhaps other chatty agents. We then would want to ensure that each priority level had the right number of shares or percentage of the overall maximum the API server can handle to ensure the requests were not too delayed."}),"\n",(0,n.jsx)(t.h4,{id:"priority-and-fairness-in-action",children:"Priority and fairness in action"}),"\n",(0,n.jsx)(t.p,{children:"Since this is a relatively new feature, many existing dashboards will use the older model of maximum inflight reads and maximum inflight writes. Why this can be problematic?"}),"\n",(0,n.jsx)(t.p,{children:"What if we were giving high priority name tags to everything in the kube-system namespace, but we then installed that bad agent into that important namespace, or even simply deployed too many applications in that namespace? We could end up having the same problem we were trying to avoid! So best to keep a close eye on such situations."}),"\n",(0,n.jsx)(t.p,{children:"I have broken out for you some of the metrics I find most interesting to track these kinds of issues."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"What percentage of a priority group\u2019s shares are used?"}),"\n",(0,n.jsx)(t.li,{children:"What is the longest time a request waited in a queue?"}),"\n",(0,n.jsx)(t.li,{children:"Which flow is using the most shares?"}),"\n",(0,n.jsx)(t.li,{children:"Are there unexpected delays on the system?"}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"percent-in-use",children:"Percent in use"}),"\n",(0,n.jsx)(t.p,{children:"Here we see the different default priority groups on the cluster and what percentage of the max is used."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-4",src:s(10107).A+"",width:"1652",height:"424"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Figure: Priority groups on the cluster."})}),"\n",(0,n.jsx)(t.h4,{id:"time-request-was-in-queue",children:"Time request was in queue"}),"\n",(0,n.jsx)(t.p,{children:"How long in seconds the request sat in the priority queue before being processed."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-5",src:s(8798).A+"",width:"999",height:"369"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Figure: Time the request was in priority queue."})}),"\n",(0,n.jsx)(t.h4,{id:"top-executed-requests-by-flow",children:"Top executed requests by flow"}),"\n",(0,n.jsx)(t.p,{children:"Which flow is taking up the most shares?"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-6",src:s(88393).A+"",width:"967",height:"371"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Figure: Top executing requests by flow."})}),"\n",(0,n.jsx)(t.h4,{id:"request-execution-time",children:"Request Execution Time"}),"\n",(0,n.jsx)(t.p,{children:"Are there any unexpected delays in processing?"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-7",src:s(33132).A+"",width:"976",height:"369"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Figure: Flow control request execution time."})}),"\n",(0,n.jsx)(t.h3,{id:"identifying-slowest-api-calls-and-api-server-latency-issues",children:"Identifying slowest API calls and API Server Latency Issues"}),"\n",(0,n.jsx)(t.p,{children:"Now that we understand the nature of the things that cause API latency, we can take a step back and look at the big picture. It\u2019s important to remember that our dashboard designs are simply trying to get a quick snapshot if there is a problem we should be investigating. For detailed analysis, we would use ad-hoc queries with PromQL\u2014or better yet, logging queries."}),"\n",(0,n.jsx)(t.p,{children:"What are some ideas for the high-level metrics we would want to look at?"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["What API call is taking the most time to complete?","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"What is the call doing? (Listing objects, deleting them, etc.)"}),"\n",(0,n.jsx)(t.li,{children:"What objects is it trying to do that operation on? (Pods, Secrets, ConfigMaps, etc.)"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["Is there a latency problem on the API server itself?","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Is there a delay in one of my priority queues causing a backup in requests?"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.li,{children:"Does it just look like API server is slow because the etcd server is experiencing latency?"}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"slowest-api-call",children:"Slowest API call"}),"\n",(0,n.jsx)(t.p,{children:"In the below chart we are looking for the API calls that took the most time to complete for that period. In this case we see a custom resource definition (CRD) is calling a LIST function that is the most latent call during the 05:40 time frame. Armed with this data we can use CloudWatch Insights to pull LIST requests from the audit log in that timeframe to see which application this might be."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-8",src:s(93967).A+"",width:"941",height:"409"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Figure: Top 5 slowest API calls."})}),"\n",(0,n.jsx)(t.h4,{id:"api-request-duration",children:"API Request Duration"}),"\n",(0,n.jsx)(t.p,{children:"This API latency chart helps us to understand if any requests are approaching the timeout value of one minute. I like the histogram over time format below as I can see outliers in the data that a line graph would hide."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-9",src:s(17586).A+"",width:"845",height:"416"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Figure: API Request duration heatmap."})}),"\n",(0,n.jsxs)(t.p,{children:["Simply hovering over a bucket shows us the exact number of calls that took around 25 milliseconds.\n[Image: Image.jpg]",(0,n.jsx)(t.em,{children:"Figure: Calls over 25 milliseconds."})]}),"\n",(0,n.jsx)(t.p,{children:"This concept is important when we are working with other systems that cache requests. Cache requests will be fast; we do not want to merge those request latencies with slower requests. Here we can see two distinct bands of latency, requests that have been cached, and those that have not."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-10",src:s(25368).A+"",width:"774",height:"229"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Figure: Latency, requests cached."})}),"\n",(0,n.jsx)(t.h4,{id:"etcd-request-duration",children:"ETCD Request Duration"}),"\n",(0,n.jsxs)(t.p,{children:["ETCD latency is one of the most important factors in Kubernetes performance. Amazon EKS allows you see this performance from the API server\u2019s perspective by looking at the ",(0,n.jsx)(t.code,{children:"request_duration_seconds_bucket"})," metric."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-11",src:s(29685).A+"",width:"886",height:"440"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsxs)(t.em,{children:["Figure : ",(0,n.jsx)(t.code,{children:"request_duration_seconds_bucket"})," metric."]})}),"\n",(0,n.jsx)(t.p,{children:"We can now start to put the things we learned together by seeing if certain events are correlated. In the below chart we see API server latency, but we also see much of this latency is coming from the etcd server. Being able to quickly move to the right problem area with just a glance is what makes a dashboard powerful."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"API-MON-12",src:s(53962).A+"",width:"871",height:"473"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.em,{children:"Figure: Etcd Requests"})}),"\n",(0,n.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsxs)(t.p,{children:["In this section of Observability best practices guide, We used a ",(0,n.jsx)(t.a,{href:"https://github.com/RiskyAdventure/Troubleshooting-Dashboards/blob/main/api-troubleshooter.json",children:"starter dashboard"})," using Amazon Managed Service for Prometheus and Amazon Managed Grafana to help you with troubleshooting ",(0,n.jsx)(t.a,{href:"https://aws.amazon.com/eks",children:"Amazon Elastic Kubernetes Service (Amazon EKS)"})," API Servers. Further, we deep dived around understanding problems while troubleshooting the EKS API Servers, API priority and fairness, stopping bad behaviours. Finally deep dived  in indentifying API calls that are slowest and API server latency issues which helps us to take actions to keep state of our Amazon EKS cluster healthy. For further deep dive, we would highly recommend you to practice Application Monitoring module under AWS native Observability category of AWS ",(0,n.jsx)(t.a,{href:"https://catalog.workshops.aws/observability/en-US",children:"One Observability Workshop"}),"."]})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},51930:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-1-6beca6db67fd83b66ee810e950a174a0.jpg"},25368:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-10-951cb182ad00cf55c12c569f53a8f6f7.jpg"},29685:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-11-41907cb5ef379332cd272ba6e67191e6.jpg"},53962:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-12-ce420a9849f95a4d8d12af13860b91c8.jpg"},78514:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-2-319b357b94ac8442fd7e15809db19003.jpg"},12168:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-3-1f15dc0e228fff08b1ee9d167b6f7411.jpg"},10107:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-4-fc5a08408f764524f2960e1b0e6d8352.jpg"},8798:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-5-b3d3c2243725460655927eba3379e00f.jpg"},88393:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-6-99bad57bd277923055a5074b247259e1.jpg"},33132:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-7-0b77723bbfea585d2bf33f2f43f8cd5e.jpg"},93967:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-8-b05232ee0fadf479574e6e80f429825d.jpg"},17586:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/api-mon-9-90c5abd6685cd0b05e2f38876d648d2a.jpg"},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>r});var n=s(96540);const i={},a=n.createContext(i);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);