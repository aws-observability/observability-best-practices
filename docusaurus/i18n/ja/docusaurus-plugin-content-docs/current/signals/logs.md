# ログ

ログは、アプリケーションまたはアプライアンスによって送信される一連のメッセージであり、イベントに関する詳細、または場合によってはそのアプリケーションの健全性に関する詳細を 1 行以上で表現したものです。通常、ログはファイルに配信されますが、分析と集約を実行するコレクターに送信されることもあります。ログデータの生成、取り込み、管理のタスクを、1 日あたり数メガバイトから 1 時間あたり数テラバイトまで、あらゆる量で実現することを目的とした、多機能なログアグリゲーター、フレームワーク、製品が数多く存在します。

ログは一度に単一のアプリケーションによって出力され、通常は*その 1 つのアプリケーション*のスコープに関連します。ただし、開発者は必要に応じてログを複雑で微妙なものにすることができます。ここでは、ログは[トレース](../signals/traces)とは根本的に異なるシグナルであると考えます。トレースは複数のアプリケーションまたはサービスからのイベントで構成され、応答レイテンシー、サービス障害、リクエストパラメータなど、サービス間の接続に関するコンテキストを含みます。

ログ内のデータは、一定期間にわたって集約することもできます。たとえば、統計的なデータ（前の 1 分間に処理されたリクエストの数など）である場合があります。構造化されている場合もあれば、自由形式、冗長、またはあらゆる記述言語で記述されている場合もあります。

ログ記録の主な使用例は、記述することです。

* イベント（ステータス、期間、その他の重要な統計情報を含む）
* そのイベントに関連するエラーまたは警告（スタックトレース、タイムアウトなど）
* アプリケーションの起動、開始メッセージ、シャットダウンメッセージ

:::note
	ログは*不変*であることを意図しており、多くのログ管理システムには、ログデータの変更を防止し、変更の試みを検出するメカニズムが含まれています。 
:::
ログ記録の要件に関係なく、これらは私たちが特定したベストプラクティスです。 

## 構造化ログが成功の鍵

多くのシステムは、半構造化形式でログを出力します。たとえば、Apache Web サーバーは次のようなログを書き込む場合があります。各行は単一の Web リクエストに関連しています。

192.168.2.20 - - [28/Jul/2006:10:27:10 -0300] "GET /cgi-bin/try/ HTTP/1.0" 200 3395
	127.0.0.1 - - [28/Jul/2006:10:22:04 -0300] "GET / HTTP/1.0" 200 2216

一方、Java スタックトレースは、複数行にまたがる単一のイベントであり、構造化されていない場合があります。

	Exception in thread "main" java.lang.NullPointerException
        at com.example.myproject.Book.getTitle(Book.java:16)
        at com.example.myproject.Author.getBookTitles(Author.java:25)
        at com.example.myproject.Bootstrap.main(Bootstrap.java:14)

Python エラーログイベントは次のようになります。
```
	Traceback (most recent call last):
	  File "e.py", line 7, in <module>
	    raise TypeError("Again !?!")
	TypeError: Again !?!
```
これら 3 つの例のうち、人間*と*ログ集約システムの両方で簡単に解析できるのは最初の例だけです。構造化ログを使用すると、ログデータを迅速かつ効果的に処理できるため、人間とマシンの両方が必要なデータを即座に見つけることができます。

最も一般的に理解されるログ形式は JSON です。JSON では、イベントの各コンポーネントがキー/バリューペアとして表現されます。JSON では、上記の Python の例は次のように書き換えられます。
```
	{
		"level", "ERROR"
		"file": "e.py",
		"line": 7,
		"error": "TypeError(\"Again !?!\")"
	}
```
構造化ログを使用することで、あるログシステムから別のログシステムへのデータの移植が可能になり、開発が簡素化され、運用診断が高速化されます(エラーも減少します)。また、JSON を使用することで、ログメッセージのスキーマが実際のデータとともに埋め込まれるため、高度なログ分析システムがメッセージを自動的にインデックス化できるようになります。

## ログレベルを適切に使用する

ログには、*レベル*を持つものと、一連のイベントであるものの 2 種類があります。レベルを持つログは、ログ戦略を成功させるための重要な要素です。ログレベルはフレームワークによって若干異なりますが、一般的には次の構造に従います。

| Level | Description |
| ----- | ----------- |
| `DEBUG` | Fine-grained informational events that are most useful to debug an application. These are usually of value to devlopers and are very verbose. |
| `INFO` | Informational messages that highlight the progress of the application at coarse-grained level. |
| `WARN` | Potentially harmful situations that indicate a risk to an application. These can trigger an alarm in an applicaiton. |
| `ERROR` | Error events that might still allow the application to continue running. These are likely to trigger an alarm that requires attention. |
| `FATAL` | Very severe error events that will presumably cause an application to abort. |

:::info
	明示的なレベルを持たないログは、暗黙的に次のように見なされる場合があります `INFO`ただし、この動作はアプリケーションによって異なる場合があります。
:::
その他の一般的なログレベルは `CRITICAL` および `NONE`、ニーズ、プログラミング言語、フレームワークに応じて選択できます。 `ALL` および `NONE` も一般的ですが、すべてのアプリケーションスタックに含まれているわけではありません。

ログレベルは、環境の健全性について監視およびオブザーバビリティソリューションに通知するために重要であり、ログデータは論理値を使用してこのデータを簡単に表現できる必要があります。 

:::tip
	あまりにも多くのデータをログに記録すると `WARN` 監視システムが限られた価値しかないデータで満たされ、膨大な量のメッセージの中で重要なデータを見失う可能性があります。  
:::
![Logs flowchart](./images/logs1.png)

:::info
	標準化されたログレベル戦略を使用することで、自動化が容易になり、開発者が問題の根本原因を迅速に特定できるようになります。
:::

:::warning
	ログレベルに対する標準的なアプローチがないと、[ログのフィルタリング](#ソースに近い場所でログをフィルタリングする)は大きな課題となります。
:::
## ソースに近い場所でログをフィルタリングする

可能な限り、ソースにできるだけ近い場所でログの量を削減してください。このベストプラクティスに従うべき理由は多数あります。

* ログの取り込みには常に時間、コスト、リソースがかかります。
* ダウンストリームシステムから機密データ (個人を特定できるデータなど) をフィルタリングすることで、データ漏洩によるリスクを軽減できます。
* ダウンストリームシステムは、データソースと同じ運用上の懸念事項を持たない場合があります。たとえば、 `INFO` アプリケーションからのログは、監視およびアラートシステムにとって関心がない場合があります。このシステムは次のものを監視します `CRITCAL` または `FATAL` メッセージ。
* ログシステムとネットワークに過度なストレスやトラフィックをかける必要はありません。

:::info
	コストを抑え、データ漏洩のリスクを減らし、各コンポーネントを[重要なこと](../guides/#重要なことを監視する)に集中させるために、ソースに近い場所でログをフィルタリングします。
:::

:::tip
	アーキテクチャによっては、Infrastructure as Code (IaC) を使用して、アプリケーション*と*環境への変更を 1 回の操作でデプロイすることをお勧めします。このアプローチにより、ログフィルターパターンをアプリケーションと一緒にデプロイでき、同じ厳密さと扱いを提供できます。
:::
## 二重取り込みのアンチパターンを回避する

管理者が追求する一般的なパターンは、すべてのログデータを単一のシステムにコピーし、単一の場所からすべてのログをクエリすることを目標とすることです。これにはいくつかの手動ワークフローの利点がありますが、このパターンは追加のコスト、複雑さ、障害点、および運用オーバーヘッドをもたらします。

![Double log ingestion](./images/logs2.png)

:::info
	可能な限り、[ログレベル](#ログレベルを適切に使用する)と[ログフィルタリング](#ソースに近い場所でログをフィルタリングする)を組み合わせて使用し、環境からのログデータの大規模な伝播を回避してください。
:::

:::info
	一部の組織やワークロードでは、規制要件を満たすため、ログを安全な場所に保存するため、否認防止を提供するため、またはその他の目的を達成するために、[ログシッピング](https://en.wikipedia.org/wiki/Log_shipping)が必要です。これは、ログデータを再取り込みする一般的なユースケースです。これらのログアーカイブに入る不要なデータの量を削減するには、[ログレベル](#ログレベルを適切に使用する)と[ログフィルタリング](#ソースに近い場所でログをフィルタリングする)を適切に適用することが依然として重要です。
:::
## ログからメトリクスデータを収集する

ログには、収集を待っている[メトリクス](../signals/metrics/)が含まれています。ISV ソリューションや自分で作成していないアプリケーションでも、ログに貴重なデータを出力しており、そこからワークロード全体の健全性に関する有意義な洞察を抽出できます。一般的な例には次のようなものがあります。

* データベースからのスロークエリ時間
* Web サーバーからの稼働時間
* トランザクション処理時間
* カウント数 `ERROR` または `WARNING` 経時的なイベント
* アップグレード可能なパッケージの生の数

:::tip
	このデータは、静的なログファイルに閉じ込められていると有用性が低くなります。ベストプラクティスは、主要なメトリクスデータを特定し、それを他のシグナルと相関させることができるメトリクスシステムに発行することです。
:::
## `stdout` にログを記録する

可能な限り、アプリケーションは次の場所にログを記録する必要があります `stdout` ファイルやソケットなどの固定された場所ではなく、標準出力に出力します。これにより、ログエージェントは、独自のオブザーバビリティソリューションに適したルールに基づいてログイベントを収集およびルーティングできます。すべてのアプリケーションで可能というわけではありませんが、これはコンテナ化されたワークロードのベストプラクティスです。

:::note
	アプリケーションはログ記録の実践においてジェネリックでシンプルであるべきであり、ログソリューションから疎結合を保つべきですが、ログデータの送信には、データを送信するための[ログコレクター](../tools/logs/)が必要です。 `stdout` ファイルに出力します。重要な概念は、アプリケーションとビジネスロジックがロギングインフラストラクチャに依存しないようにすることです。つまり、関心事を分離するように努める必要があります。
:::

:::info
	アプリケーションをログ管理から分離することで、コード変更なしでソリューションを適応および進化させることができ、環境に加えた変更の潜在的な影響範囲を最小限に抑えることができます。
:::