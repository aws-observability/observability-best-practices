<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-guides/containers/aws-native/eks/eks-api-server-monitoring" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.4.0">
<title data-rh="true">Amazon EKS API Server Monitoring | AWS Observability Best Practices</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://aws-observability.github.io/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" property="og:locale:alternate" content="ja"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Amazon EKS API Server Monitoring | AWS Observability Best Practices"><meta data-rh="true" name="description" content="In this section of Observability best practices guide, we will deep dive on to following topics related to API Server Monitoring:"><meta data-rh="true" property="og:description" content="In this section of Observability best practices guide, we will deep dive on to following topics related to API Server Monitoring:"><link data-rh="true" rel="icon" href="/observability-best-practices/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://aws-observability.github.io/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring"><link data-rh="true" rel="alternate" href="https://aws-observability.github.io/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring" hreflang="en"><link data-rh="true" rel="alternate" href="https://aws-observability.github.io/observability-best-practices/ja/guides/containers/aws-native/eks/eks-api-server-monitoring" hreflang="ja"><link data-rh="true" rel="alternate" href="https://aws-observability.github.io/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/observability-best-practices/blog/rss.xml" title="AWS Observability Best Practices RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/observability-best-practices/blog/atom.xml" title="AWS Observability Best Practices Atom Feed"><link rel="stylesheet" href="/observability-best-practices/assets/css/styles.d16a0acd.css">
<script src="/observability-best-practices/assets/js/runtime~main.2b49a13a.js" defer="defer"></script>
<script src="/observability-best-practices/assets/js/main.2dc61b2f.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();null!==e?t(e):window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,t("light"))}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/observability-best-practices/"><div class="navbar__logo"><img src="/observability-best-practices/img/logo.svg" alt="AWS Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/observability-best-practices/img/logo.svg" alt="AWS Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">AWS Observability Best Practices</b></a><a class="navbar__item navbar__link" href="/observability-best-practices/home">Home</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/observability-best-practices/guides/">Guides</a><a class="navbar__item navbar__link" href="/observability-best-practices/signals/alarms">Signals</a><a class="navbar__item navbar__link" href="/observability-best-practices/tools/observability_accelerator">Tools</a><a class="navbar__item navbar__link" href="/observability-best-practices/recipes/">Recipes</a><a class="navbar__item navbar__link" href="/observability-best-practices/faq/adot">FAQ</a><a class="navbar__item navbar__link" href="/observability-best-practices/patterns/multiaccount">Patterns</a><a class="navbar__item navbar__link" href="/observability-best-practices/contributors">Contributors</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>English</a><ul class="dropdown__menu"><li><a href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="en">English</a></li><li><a href="/observability-best-practices/ja/guides/containers/aws-native/eks/eks-api-server-monitoring" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="ja">日本語</a></li></ul></div><a href="https://github.com/aws-observability/observability-best-practices" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/observability-best-practices/guides/">Guides</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/observability-best-practices/guides/">Best practices overview</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/observability-best-practices/guides/choosing-a-tracing-agent">Choosing a tracing agent</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/observability-best-practices/guides/cost/kubecost">Cost</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/observability-best-practices/guides/databases/rds-and-aurora">Databases</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/observability-best-practices/guides/ec2-monitoring">EC2 Monitoring and Observability</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/observability-best-practices/guides/containers/aws-native/ecs/best-practices-metrics-collection-1">ECS best practices</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" tabindex="0" href="/observability-best-practices/guides/containers/aws-native/eks/amazon-cloudwatch-container-insights">EKS best practices</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" tabindex="0" href="/observability-best-practices/guides/containers/aws-native/eks/amazon-cloudwatch-container-insights">AWS Native</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/observability-best-practices/guides/containers/aws-native/eks/amazon-cloudwatch-container-insights">Amazon CloudWatch Container Insights</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/observability-best-practices/guides/containers/aws-native/eks/log-aggregation">Log Aggregation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring">Amazon EKS API Server Monitoring</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/observability-best-practices/guides/containers/aws-native/eks/container-tracing-with-aws-xray">Container Tracing with AWS X-Ray</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/observability-best-practices/guides/containers/oss/eks/best-practices-metrics-collection">Open Source</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/observability-best-practices/guides/serverless/aws-native/lambda-based-observability">Serverless best practices</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/observability-best-practices/guides/hybrid-and-multicloud">Best practices for hybrid and multicloud</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/observability-best-practices/guides/operational/adot-at-scale/operating-adot-collector">Operational</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/observability-best-practices/guides/signal-collection/emf">Signal collection</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/observability-best-practices/guides/partners/databricks">Partners</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/observability-best-practices/guides/observability-maturity-model">AWS Observability Maturity Model</a></li></ul></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/observability-best-practices/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Guides</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">EKS best practices</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">AWS Native</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Amazon EKS API Server Monitoring</span><meta itemprop="position" content="4"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Amazon EKS API Server Monitoring</h1>
<p>In this section of Observability best practices guide, we will deep dive on to following topics related to API Server Monitoring:</p>
<ul>
<li>Introduction to Amazon EKS API Server Monitoring</li>
<li>Setting up an API Server Troubleshooter Dashboard</li>
<li>Using API Troubleshooter Dashboard to Understand API Server Problems</li>
<li>Understanding Unbounded list calls to API Server</li>
<li>Stopping bad behavior to API Server</li>
<li>API Priority and Fairness</li>
<li>Identifying slowest API calls and API Server Latency Issues</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#introduction">​</a></h3>
<p>Monitoring your Amazon EKS managed control plane is a very important Day 2 operational activity to proactively identity issues with health of your EKS cluster. Amazon EKS Control plane monitoring helps you to take proactive measures based on the collected metrics. These metrics would helps us to troubleshoot the API servers and pin point the problem under the hood.</p>
<p>We will be using Amazon Managed Service for Prometheus (AMP) for our demonstration in this section for Amazon EKS API server monitoring and Amazon Managed Grafana (AMG) for visualization of metrics. Prometheus is a popular open source monitoring tool that provides powerful querying features and has wide support for a variety of workloads. Amazon Managed Service for Prometheus is a fully managed Prometheus-compatible service that makes it easier to monitor environments, such as Amazon EKS, <a href="http://aws.amazon.com/ecs" target="_blank" rel="noopener noreferrer">Amazon Elastic Container Service (Amazon ECS)</a>, and <a href="http://aws.amazon.com/ec2" target="_blank" rel="noopener noreferrer">Amazon Elastic Compute Cloud (Amazon EC2)</a>, securely and reliably. <a href="https://aws.amazon.com/grafana/" target="_blank" rel="noopener noreferrer">Amazon Managed Grafana</a> is a fully managed and secure data visualization service for open source Grafana that enables customers to instantly query, correlate, and visualize operational metrics, logs, and traces for their applications from multiple data sources</p>
<p>We will first setup a starter dashboard using Amazon Managed Service for Prometheus and Amazon Managed Grafana to help you with troubleshooting <a href="https://aws.amazon.com/eks" target="_blank" rel="noopener noreferrer">Amazon Elastic Kubernetes Service (Amazon EKS)</a> API Servers with Prometheus. We will diving deep in up coming sections around understanding problems while troubleshooting the EKS API Servers, API priority and fairness, stopping bad behaviours. Finally we will deep dive in indentifying API calls that are slowest and API server latency issues which helps us to take actions to keep state of our Amazon EKS cluster healthy.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="setting-up-an-api-server-troubleshooter-dashboard">Setting up an API Server Troubleshooter Dashboard<a class="hash-link" aria-label="Direct link to Setting up an API Server Troubleshooter Dashboard" title="Direct link to Setting up an API Server Troubleshooter Dashboard" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#setting-up-an-api-server-troubleshooter-dashboard">​</a></h3>
<p>We will setup a starter dashboard to help you with troubleshooting <a href="https://aws.amazon.com/eks" target="_blank" rel="noopener noreferrer">Amazon Elastic Kubernetes Service (Amazon EKS)</a> API Servers with AMP. We will use this to help you understand the metrics while troubleshooting your production EKS clusters. We will further focus deep on the collected metrics to understand its importance while troubleshooting your Amazon EKS clusters.</p>
<p>First, setup an <a href="https://aws.amazon.com/blogs/containers/metrics-and-traces-collection-using-amazon-eks-add-ons-for-aws-distro-for-opentelemetry/" target="_blank" rel="noopener noreferrer">ADOT collector to collect metrics from your Amazon EKS cluster to Amazon Manager Service for Prometheus</a>. In this setup you will be using EKS ADOT Addon which  allows users to enable ADOT as an add-on at any time after the EKS cluster is up and running. The ADOT add-on includes the latest security patches and bug fixes and is validated by AWS to work with Amazon EKS. This setup will show you how to install the ADOT add-on in an EKS cluster and then use it to collect metrics from your cluster.</p>
<p>Next, <a href="https://aws.amazon.com/blogs/mt/amazon-managed-grafana-getting-started/" target="_blank" rel="noopener noreferrer">setup your Amazon Managed Grafana workspace to visualize metrics using AMP</a> as a data source which you have setup in the first step. Finally download the <a href="https://github.com/RiskyAdventure/Troubleshooting-Dashboards/blob/main/api-troubleshooter.json" target="_blank" rel="noopener noreferrer">API troubleshooter dashboard</a>, navigate to Amazon Managed Grafana to upload the API troubleshooter dashboard json to visualize the metrics for further troubleshooting.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="using-api-troubleshooter-dashboard-to-understand-problems">Using API Troubleshooter Dashboard to Understand Problems<a class="hash-link" aria-label="Direct link to Using API Troubleshooter Dashboard to Understand Problems" title="Direct link to Using API Troubleshooter Dashboard to Understand Problems" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#using-api-troubleshooter-dashboard-to-understand-problems">​</a></h3>
<p>Let’s say you found an interesting open-source project that you wanted to install in your cluster. That operator deploys a DaemonSet to your cluster that might be using malformed requests, a needlessly high volume of LIST calls, or maybe each of its DaemonSets across all your 1,000 nodes are requesting status of all 50,000 pods on your cluster every minute!
Does this really happen often? Yes, it does! Let’s take a quick detour on how that happens.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="understanding-list-vs-watch">Understanding LIST vs. WATCH<a class="hash-link" aria-label="Direct link to Understanding LIST vs. WATCH" title="Direct link to Understanding LIST vs. WATCH" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#understanding-list-vs-watch">​</a></h4>
<p>Some applications need to understand the state of the objects in your cluster. For example, your machine learning (ML) application wants to know the job status by understanding how many pods are not in the <em>Completed</em> status. In Kubernetes, there are well-behaved ways to do this with something called a WATCH, and some not-so-well-behaved ways that list every object on the cluster to find the latest status on those pods.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="a-well-behaved-watch">A well-behaved WATCH<a class="hash-link" aria-label="Direct link to A well-behaved WATCH" title="Direct link to A well-behaved WATCH" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#a-well-behaved-watch">​</a></h4>
<p>Using a WATCH or a single, long-lived connection to receive updates via a push model is the most scalable way to do updates in Kubernetes. To oversimplify, we ask for the full state of the system, then only update the object in a cache when changes are received for that object, periodically running a re-sync to ensure that no updates were missed.</p>
<p>In the below image we use the <code>apiserver_longrunning_gauge</code> to get an idea of the number of these long-lived connections across both API servers.</p>
<p><img decoding="async" loading="lazy" alt="API-MON-1" src="/observability-best-practices/assets/images/api-mon-1-6beca6db67fd83b66ee810e950a174a0.jpg" width="1613" height="361" class="img_ev3q"></p>
<p><em>Figure: <code>apiserver_longrunning_gauge</code> metric</em></p>
<p>Even with this efficient system, we can still have too much of a good thing. For example, if we use many very small nodes, each using two or more DaemonSets that need to talk to the API server, it is quite easy to dramatically increase the number of WATCH calls on the system unnecessarily. For example, let’s look at the difference between eight xlarge nodes vs. a single 8xlarge. Here we see an 8x increase of WATCH calls on the system.</p>
<p><img decoding="async" loading="lazy" alt="API-MON-2" src="/observability-best-practices/assets/images/api-mon-2-319b357b94ac8442fd7e15809db19003.jpg" width="921" height="415" class="img_ev3q"></p>
<p><em>Figure: WATCH calls between 8 xlarge nodes.</em></p>
<p>Now these are efficient calls, but what if instead they were the ill-behaved calls we alluded to earlier? Imagine if one of the above DaemonSets on each of the 1,000 nodes is requesting updates on each of the total 50,000 pods in the cluster. We will explore this idea of an unbounded list call in next section.</p>
<p>A quick word of caution before continuing, the type of consolidation in the above example must be done with great care, and has many other factors to consider. Everything from the delay of the number of threads competing for a limited number of CPUs on the system, Pod churn rate, to the maximum number of volume attachments a node can handle safely. However, our focus will be on the metrics that lead us to actionable steps that can prevent issues from happening—and maybe give us new insight into our designs.</p>
<p>The WATCH metric is a simple one, but it can be used to track and reduce the number of watches, if that is a problem for you. Here are a few options you could consider to reduce this number:</p>
<ul>
<li>Limit the number of ConfigMaps Helm creates to track History</li>
<li>Use Immutable ConfigMaps and Secrets which do not use a WATCH</li>
<li>Sensible node sizing and consolidation</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="understanding-unbounded-list-calls-to-api-server">Understanding Unbounded list calls to API Server<a class="hash-link" aria-label="Direct link to Understanding Unbounded list calls to API Server" title="Direct link to Understanding Unbounded list calls to API Server" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#understanding-unbounded-list-calls-to-api-server">​</a></h3>
<p>Now for the LIST call we have been talking about. A list call is pulling the full history on our Kubernetes objects each time we need to understand an object’s state, nothing is being saved in a cache this time.</p>
<p>How impactful is all this? That will vary depending on how many agents are requesting data, how often they are doing so, and how much data they are requesting. Are they asking for everything on the cluster, or just a single namespace? Does that happen every minute, on very node? Let’s use an example of a logging agent that is appending Kubernetes metadata on every log sent from a node. This could be an overwhelming amount of data in larger clusters. There are many ways for the agent to get that data via a list call, so let’s look at a few.</p>
<p>The below request is asking for pods from a specific namespace.</p>
<p><code>/api/v1/namespaces/my-namespace/pods</code></p>
<p>Next, we request all 50,000 pods on the cluster, but in chunks of 500 pods at a time.</p>
<p><code>/api/v1/pods?limit=500</code></p>
<p>The next call is the most disruptive. Fetching all 50,000 pods on the entire cluster at the same time.</p>
<p><code>/api/v1/pods</code></p>
<p>This happens quite commonly in the field and can be seen in the logs.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="stopping-bad-behavior-to-api-server">Stopping bad behavior to API Server<a class="hash-link" aria-label="Direct link to Stopping bad behavior to API Server" title="Direct link to Stopping bad behavior to API Server" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#stopping-bad-behavior-to-api-server">​</a></h3>
<p>How can we protect our cluster from such bad behavior? Before Kubernetes 1.20, the API server would protect itself by limiting the number of <em>inflight</em> requests processed per second. Since etcd can only handle so many requests at one time in a performant way, we need to ensure the number of requests is limited to a value per second that keeps etcd reads and writes in a reasonable latency band. Unfortunately, at the time of this writing, there is no dynamic way to do this.</p>
<p>In the below chart we see a breakdown of read requests, which has a default maximum of 400 inflight request per API server and a default max of 200 concurrent write requests. In a default EKS cluster you will see two API servers for a total of 800 reads and 400 writes. However, caution is advised as these servers can have asymmetric loads on them at different times like right after an upgrade, etc.</p>
<p><img decoding="async" loading="lazy" alt="API-MON-3" src="/observability-best-practices/assets/images/api-mon-3-1f15dc0e228fff08b1ee9d167b6f7411.jpg" width="1292" height="536" class="img_ev3q"></p>
<p><em>Figure: Grafana chart with breakdown of read requests.</em></p>
<p>It turns out that the above was not a perfect scheme. For example, how could we keep this badly behaving new operator we just installed from taking up all the inflight write requests on the API server and potentially delaying important requests such as node keepalive messages?</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="api-priority-and-fairness">API Priority and Fairness<a class="hash-link" aria-label="Direct link to API Priority and Fairness" title="Direct link to API Priority and Fairness" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#api-priority-and-fairness">​</a></h3>
<p>Instead of worrying about how many read/write requests were open per second, what if we treated the capacity as one total number, and each application on the cluster got a fair percentage or share of that total maximum number?</p>
<p>To do that that effectively, we would need to identify who sent the request to the API server, then give that request a name tag of sorts. With this new name tag, we could then see all these requests are coming from a new agent we will call “Chatty.” Now we can group all of Chatty’s requests into something called a <em>flow</em>, that identifies those requests are coming from the same DaemonSet. This concept now gives us the ability to restrict this bad agent and ensure it does not consume the whole cluster.</p>
<p>However, not all requests are created equal. The control plane traffic that is needed to keep the cluster operational should be a higher priority than our new operator. This is where the idea of priority levels comes into play. What if, by default, we had a several “buckets” or queues for critical, high, and low priority traffic? We do not want the chatty agent flow getting a fair share of traffic in the critical traffic queue. We can however put that traffic in a low priority queue so that flow is competing with perhaps other chatty agents. We then would want to ensure that each priority level had the right number of shares or percentage of the overall maximum the API server can handle to ensure the requests were not too delayed.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="priority-and-fairness-in-action">Priority and fairness in action<a class="hash-link" aria-label="Direct link to Priority and fairness in action" title="Direct link to Priority and fairness in action" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#priority-and-fairness-in-action">​</a></h4>
<p>Since this is a relatively new feature, many existing dashboards will use the older model of maximum inflight reads and maximum inflight writes. Why this can be problematic?</p>
<p>What if we were giving high priority name tags to everything in the kube-system namespace, but we then installed that bad agent into that important namespace, or even simply deployed too many applications in that namespace? We could end up having the same problem we were trying to avoid! So best to keep a close eye on such situations.</p>
<p>I have broken out for you some of the metrics I find most interesting to track these kinds of issues.</p>
<ul>
<li>What percentage of a priority group’s shares are used?</li>
<li>What is the longest time a request waited in a queue?</li>
<li>Which flow is using the most shares?</li>
<li>Are there unexpected delays on the system?</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="percent-in-use">Percent in use<a class="hash-link" aria-label="Direct link to Percent in use" title="Direct link to Percent in use" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#percent-in-use">​</a></h4>
<p>Here we see the different default priority groups on the cluster and what percentage of the max is used.</p>
<p><img decoding="async" loading="lazy" alt="API-MON-4" src="/observability-best-practices/assets/images/api-mon-4-fc5a08408f764524f2960e1b0e6d8352.jpg" width="1652" height="424" class="img_ev3q"></p>
<p><em>Figure: Priority groups on the cluster.</em></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="time-request-was-in-queue">Time request was in queue<a class="hash-link" aria-label="Direct link to Time request was in queue" title="Direct link to Time request was in queue" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#time-request-was-in-queue">​</a></h4>
<p>How long in seconds the request sat in the priority queue before being processed.</p>
<p><img decoding="async" loading="lazy" alt="API-MON-5" src="/observability-best-practices/assets/images/api-mon-5-b3d3c2243725460655927eba3379e00f.jpg" width="999" height="369" class="img_ev3q"></p>
<p><em>Figure: Time the request was in priority queue.</em></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="top-executed-requests-by-flow">Top executed requests by flow<a class="hash-link" aria-label="Direct link to Top executed requests by flow" title="Direct link to Top executed requests by flow" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#top-executed-requests-by-flow">​</a></h4>
<p>Which flow is taking up the most shares?</p>
<p><img decoding="async" loading="lazy" alt="API-MON-6" src="/observability-best-practices/assets/images/api-mon-6-99bad57bd277923055a5074b247259e1.jpg" width="967" height="371" class="img_ev3q"></p>
<p><em>Figure: Top executing requests by flow.</em></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="request-execution-time">Request Execution Time<a class="hash-link" aria-label="Direct link to Request Execution Time" title="Direct link to Request Execution Time" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#request-execution-time">​</a></h4>
<p>Are there any unexpected delays in processing?</p>
<p><img decoding="async" loading="lazy" alt="API-MON-7" src="/observability-best-practices/assets/images/api-mon-7-0b77723bbfea585d2bf33f2f43f8cd5e.jpg" width="976" height="369" class="img_ev3q"></p>
<p><em>Figure: Flow control request execution time.</em></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="identifying-slowest-api-calls-and-api-server-latency-issues">Identifying slowest API calls and API Server Latency Issues<a class="hash-link" aria-label="Direct link to Identifying slowest API calls and API Server Latency Issues" title="Direct link to Identifying slowest API calls and API Server Latency Issues" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#identifying-slowest-api-calls-and-api-server-latency-issues">​</a></h3>
<p>Now that we understand the nature of the things that cause API latency, we can take a step back and look at the big picture. It’s important to remember that our dashboard designs are simply trying to get a quick snapshot if there is a problem we should be investigating. For detailed analysis, we would use ad-hoc queries with PromQL—or better yet, logging queries.</p>
<p>What are some ideas for the high-level metrics we would want to look at?</p>
<ul>
<li>What API call is taking the most time to complete?<!-- -->
<ul>
<li>What is the call doing? (Listing objects, deleting them, etc.)</li>
<li>What objects is it trying to do that operation on? (Pods, Secrets, ConfigMaps, etc.)</li>
</ul>
</li>
<li>Is there a latency problem on the API server itself?<!-- -->
<ul>
<li>Is there a delay in one of my priority queues causing a backup in requests?</li>
</ul>
</li>
<li>Does it just look like API server is slow because the etcd server is experiencing latency?</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="slowest-api-call">Slowest API call<a class="hash-link" aria-label="Direct link to Slowest API call" title="Direct link to Slowest API call" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#slowest-api-call">​</a></h4>
<p>In the below chart we are looking for the API calls that took the most time to complete for that period. In this case we see a custom resource definition (CRD) is calling a LIST function that is the most latent call during the 05:40 time frame. Armed with this data we can use CloudWatch Insights to pull LIST requests from the audit log in that timeframe to see which application this might be.</p>
<p><img decoding="async" loading="lazy" alt="API-MON-8" src="/observability-best-practices/assets/images/api-mon-8-b05232ee0fadf479574e6e80f429825d.jpg" width="941" height="409" class="img_ev3q"></p>
<p><em>Figure: Top 5 slowest API calls.</em></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="api-request-duration">API Request Duration<a class="hash-link" aria-label="Direct link to API Request Duration" title="Direct link to API Request Duration" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#api-request-duration">​</a></h4>
<p>This API latency chart helps us to understand if any requests are approaching the timeout value of one minute. I like the histogram over time format below as I can see outliers in the data that a line graph would hide.</p>
<p><img decoding="async" loading="lazy" alt="API-MON-9" src="/observability-best-practices/assets/images/api-mon-9-90c5abd6685cd0b05e2f38876d648d2a.jpg" width="845" height="416" class="img_ev3q"></p>
<p><em>Figure: API Request duration heatmap.</em></p>
<p>Simply hovering over a bucket shows us the exact number of calls that took around 25 milliseconds.
[Image: Image.jpg]<em>Figure: Calls over 25 milliseconds.</em></p>
<p>This concept is important when we are working with other systems that cache requests. Cache requests will be fast; we do not want to merge those request latencies with slower requests. Here we can see two distinct bands of latency, requests that have been cached, and those that have not.</p>
<p><img decoding="async" loading="lazy" alt="API-MON-10" src="/observability-best-practices/assets/images/api-mon-10-951cb182ad00cf55c12c569f53a8f6f7.jpg" width="774" height="229" class="img_ev3q"></p>
<p><em>Figure: Latency, requests cached.</em></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="etcd-request-duration">ETCD Request Duration<a class="hash-link" aria-label="Direct link to ETCD Request Duration" title="Direct link to ETCD Request Duration" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#etcd-request-duration">​</a></h4>
<p>ETCD latency is one of the most important factors in Kubernetes performance. Amazon EKS allows you see this performance from the API server’s perspective by looking at the <code>request_duration_seconds_bucket</code> metric.</p>
<p><img decoding="async" loading="lazy" alt="API-MON-11" src="/observability-best-practices/assets/images/api-mon-11-41907cb5ef379332cd272ba6e67191e6.jpg" width="886" height="440" class="img_ev3q"></p>
<p><em>Figure : <code>request_duration_seconds_bucket</code> metric.</em></p>
<p>We can now start to put the things we learned together by seeing if certain events are correlated. In the below chart we see API server latency, but we also see much of this latency is coming from the etcd server. Being able to quickly move to the right problem area with just a glance is what makes a dashboard powerful.</p>
<p><img decoding="async" loading="lazy" alt="API-MON-12" src="/observability-best-practices/assets/images/api-mon-12-ce420a9849f95a4d8d12af13860b91c8.jpg" width="871" height="473" class="img_ev3q"></p>
<p><em>Figure: Etcd Requests</em></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#conclusion">​</a></h2>
<p>In this section of Observability best practices guide, We used a <a href="https://github.com/RiskyAdventure/Troubleshooting-Dashboards/blob/main/api-troubleshooter.json" target="_blank" rel="noopener noreferrer">starter dashboard</a> using Amazon Managed Service for Prometheus and Amazon Managed Grafana to help you with troubleshooting <a href="https://aws.amazon.com/eks" target="_blank" rel="noopener noreferrer">Amazon Elastic Kubernetes Service (Amazon EKS)</a> API Servers. Further, we deep dived around understanding problems while troubleshooting the EKS API Servers, API priority and fairness, stopping bad behaviours. Finally deep dived  in indentifying API calls that are slowest and API server latency issues which helps us to take actions to keep state of our Amazon EKS cluster healthy. For further deep dive, we would highly recommend you to practice Application Monitoring module under AWS native Observability category of AWS <a href="https://catalog.workshops.aws/observability/en-US" target="_blank" rel="noopener noreferrer">One Observability Workshop</a>.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/aws-observability/observability-best-practices/blob/main/docusaurus/docs/guides/containers/aws-native/eks/eks-api-server-monitoring.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/observability-best-practices/guides/containers/aws-native/eks/log-aggregation"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Log Aggregation</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/observability-best-practices/guides/containers/aws-native/eks/container-tracing-with-aws-xray"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Container Tracing with AWS X-Ray</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a class="table-of-contents__link toc-highlight" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#introduction">Introduction</a></li><li><a class="table-of-contents__link toc-highlight" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#setting-up-an-api-server-troubleshooter-dashboard">Setting up an API Server Troubleshooter Dashboard</a></li><li><a class="table-of-contents__link toc-highlight" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#using-api-troubleshooter-dashboard-to-understand-problems">Using API Troubleshooter Dashboard to Understand Problems</a></li><li><a class="table-of-contents__link toc-highlight" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#understanding-unbounded-list-calls-to-api-server">Understanding Unbounded list calls to API Server</a></li><li><a class="table-of-contents__link toc-highlight" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#stopping-bad-behavior-to-api-server">Stopping bad behavior to API Server</a></li><li><a class="table-of-contents__link toc-highlight" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#api-priority-and-fairness">API Priority and Fairness</a></li><li><a class="table-of-contents__link toc-highlight" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#identifying-slowest-api-calls-and-api-server-latency-issues">Identifying slowest API calls and API Server Latency Issues</a></li><li><a class="table-of-contents__link toc-highlight" href="/observability-best-practices/guides/containers/aws-native/eks/eks-api-server-monitoring#conclusion">Conclusion</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Built with ❤️ at AWS. <br> © 2025.  Amazon.com, Inc. or its affiliates. All Rights Reserved.</div></div></div></footer></div>
</body>
</html>